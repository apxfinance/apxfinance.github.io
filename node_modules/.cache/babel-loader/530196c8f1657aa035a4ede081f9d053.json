{"ast":null,"code":"// import { Fetcher, Route, Token } from '@uniswap/sdk';\nimport { Fetcher as FetcherSpirit, Token as TokenSpirit } from '@spiritswap/sdk';\nimport { Fetcher, Route, Token } from '@spookyswap/sdk';\nimport { BigNumber, Contract, ethers } from 'ethers';\nimport { decimalToBalance } from './ether-utils';\nimport ERC20 from './ERC20';\nimport { getFullDisplayBalance, getDisplayBalance } from '../utils/formatBalance';\nimport { getDefaultProvider } from '../utils/provider';\nimport IUniswapV2PairABI from './IUniswapV2Pair.abi.json';\nimport config, { bankDefinitions } from '../config';\nimport moment from 'moment';\nimport { parseUnits } from 'ethers/lib/utils';\nimport { FTM_TICKER, SPOOKY_ROUTER_ADDR, TOMB_TICKER } from '../utils/constants';\n/**\n * An API module of Apex Finance contracts.\n * All contract-interacting domain logic should be defined in here.\n */\n\nexport class TombFinance {\n  constructor(cfg) {\n    this.myAccount = void 0;\n    this.provider = void 0;\n    this.signer = void 0;\n    this.config = void 0;\n    this.contracts = void 0;\n    this.externalTokens = void 0;\n    this.masonryVersionOfUser = void 0;\n    this.TOMBWFTM_LP = void 0;\n    this.APEX = void 0;\n    this.ASHARE = void 0;\n    this.ABOND = void 0;\n    this.FTM = void 0;\n    const {\n      deployments,\n      externalTokens\n    } = cfg;\n    const provider = getDefaultProvider(); // loads contracts from deployments\n\n    this.contracts = {};\n\n    for (const [name, deployment] of Object.entries(deployments)) {\n      this.contracts[name] = new Contract(deployment.address, deployment.abi, provider);\n    }\n\n    this.externalTokens = {};\n\n    for (const [symbol, [address, decimal]] of Object.entries(externalTokens)) {\n      this.externalTokens[symbol] = new ERC20(address, provider, symbol, decimal);\n    }\n\n    this.APEX = new ERC20(deployments.tomb.address, provider, 'APEX');\n    this.ASHARE = new ERC20(deployments.tShare.address, provider, 'ASHARE');\n    this.ABOND = new ERC20(deployments.tBond.address, provider, 'ABOND');\n    this.FTM = this.externalTokens['WFTM']; // Uniswap V2 Pair\n\n    this.TOMBWFTM_LP = new Contract(externalTokens['APEX-FTM-LP'][0], IUniswapV2PairABI, provider);\n    this.config = cfg;\n    this.provider = provider;\n  }\n  /**\n   * @param provider From an unlocked wallet. (e.g. Metamask)\n   * @param account An address of unlocked wallet account.\n   */\n\n\n  unlockWallet(provider, account) {\n    const newProvider = new ethers.providers.Web3Provider(provider, this.config.chainId);\n    this.signer = newProvider.getSigner(0);\n    this.myAccount = account;\n\n    for (const [name, contract] of Object.entries(this.contracts)) {\n      this.contracts[name] = contract.connect(this.signer);\n    }\n\n    const tokens = [this.APEX, this.ASHARE, this.ABOND, ...Object.values(this.externalTokens)];\n\n    for (const token of tokens) {\n      token.connect(this.signer);\n    }\n\n    this.TOMBWFTM_LP = this.TOMBWFTM_LP.connect(this.signer);\n    console.log(`ðŸ”“ Wallet is unlocked. Welcome, ${account}!`);\n    this.fetchMasonryVersionOfUser().then(version => this.masonryVersionOfUser = version).catch(err => {\n      console.error(`Failed to fetch masonry version: ${err.stack}`);\n      this.masonryVersionOfUser = 'latest';\n    });\n  }\n\n  get isUnlocked() {\n    return !!this.myAccount;\n  } //===================================================================\n  //===================== GET ASSET STATS =============================\n  //===================FROM SPOOKY TO DISPLAY =========================\n  //=========================IN HOME PAGE==============================\n  //===================================================================\n\n\n  async getTombStat() {\n    const {\n      ApexFtmRewardPool,\n      ApexFtmLPApexRewardPool,\n      ApexFtmLPApexRewardPoolOld\n    } = this.contracts;\n    const supply = await this.APEX.totalSupply();\n    const tombRewardPoolSupply = await this.APEX.balanceOf(ApexFtmRewardPool.address);\n    const tombRewardPoolSupply2 = await this.APEX.balanceOf(ApexFtmLPApexRewardPool.address); // const tombRewardPoolSupplyOld = await this.APEX.balanceOf(ApexFtmLPApexRewardPoolOld.address);\n\n    const tombCirculatingSupply = supply.sub(tombRewardPoolSupply).sub(tombRewardPoolSupply2); // .sub(tombRewardPoolSupplyOld);\n\n    const priceInFTM = await this.getTokenPriceFromPancakeswap(this.APEX);\n    const priceOfOneFTM = await this.getWFTMPriceFromPancakeswap();\n    const priceOfTombInDollars = (Number(priceInFTM) * Number(priceOfOneFTM)).toFixed(2);\n    return {\n      tokenInFtm: priceInFTM,\n      priceInDollars: priceOfTombInDollars,\n      totalSupply: getDisplayBalance(supply, this.APEX.decimal, 0),\n      circulatingSupply: getDisplayBalance(tombCirculatingSupply, this.APEX.decimal, 0)\n    };\n  }\n  /**\n   * Calculates various stats for the requested LP\n   * @param name of the LP token to load stats for\n   * @returns\n   */\n\n\n  async getLPStat(name) {\n    const lpToken = this.externalTokens[name];\n    const lpTokenSupplyBN = await lpToken.totalSupply();\n    const lpTokenSupply = getDisplayBalance(lpTokenSupplyBN, 18);\n    const token0 = name.startsWith('APEX') ? this.APEX : this.ASHARE;\n    const isTomb = name.startsWith('APEX');\n    const tokenAmountBN = await token0.balanceOf(lpToken.address);\n    const tokenAmount = getDisplayBalance(tokenAmountBN, 18);\n    const ftmAmountBN = await this.FTM.balanceOf(lpToken.address);\n    const ftmAmount = getDisplayBalance(ftmAmountBN, 18);\n    const tokenAmountInOneLP = Number(tokenAmount) / Number(lpTokenSupply);\n    const ftmAmountInOneLP = Number(ftmAmount) / Number(lpTokenSupply);\n    const lpTokenPrice = await this.getLPTokenPrice(lpToken, token0, isTomb);\n    const lpTokenPriceFixed = Number(lpTokenPrice).toFixed(2).toString();\n    const liquidity = (Number(lpTokenSupply) * Number(lpTokenPrice)).toFixed(2).toString();\n    return {\n      tokenAmount: tokenAmountInOneLP.toFixed(2).toString(),\n      ftmAmount: ftmAmountInOneLP.toFixed(2).toString(),\n      priceOfOne: lpTokenPriceFixed,\n      totalLiquidity: liquidity,\n      totalSupply: Number(lpTokenSupply).toFixed(2).toString()\n    };\n  }\n  /**\n   * Use this method to get price for Apex\n   * @returns TokenStat for ABOND\n   * priceInFTM\n   * priceInDollars\n   * TotalSupply\n   * CirculatingSupply (always equal to total supply for bonds)\n   */\n\n\n  async getBondStat() {\n    const {\n      Treasury\n    } = this.contracts;\n    const tombStat = await this.getTombStat();\n    const bondTombRatioBN = await Treasury.getBondPremiumRate();\n    const modifier = bondTombRatioBN / 1e18 > 1 ? bondTombRatioBN / 1e18 : 1;\n    const bondPriceInFTM = (Number(tombStat.tokenInFtm) * modifier).toFixed(2);\n    const priceOfTBondInDollars = (Number(tombStat.priceInDollars) * modifier).toFixed(2);\n    const supply = await this.ABOND.displayedTotalSupply();\n    return {\n      tokenInFtm: bondPriceInFTM,\n      priceInDollars: priceOfTBondInDollars,\n      totalSupply: supply,\n      circulatingSupply: supply\n    };\n  }\n  /**\n   * @returns TokenStat for ASHARE\n   * priceInFTM\n   * priceInDollars\n   * TotalSupply\n   * CirculatingSupply (always equal to total supply for bonds)\n   */\n\n\n  async getShareStat() {\n    const {\n      ApexFtmLPAShareRewardPool\n    } = this.contracts;\n    const supply = await this.ASHARE.totalSupply();\n    const priceInFTM = await this.getTokenPriceFromPancakeswap(this.ASHARE);\n    const tombRewardPoolSupply = await this.ASHARE.balanceOf(ApexFtmLPAShareRewardPool.address);\n    const tShareCirculatingSupply = supply.sub(tombRewardPoolSupply);\n    const priceOfOneFTM = await this.getWFTMPriceFromPancakeswap();\n    const priceOfSharesInDollars = (Number(priceInFTM) * Number(priceOfOneFTM)).toFixed(2);\n    return {\n      tokenInFtm: priceInFTM,\n      priceInDollars: priceOfSharesInDollars,\n      totalSupply: getDisplayBalance(supply, this.ASHARE.decimal, 0),\n      circulatingSupply: getDisplayBalance(tShareCirculatingSupply, this.ASHARE.decimal, 0)\n    };\n  }\n\n  async getTombStatInEstimatedTWAP() {\n    const {\n      SeigniorageOracle,\n      ApexFtmRewardPool\n    } = this.contracts;\n    const expectedPrice = await SeigniorageOracle.twap(this.APEX.address, ethers.utils.parseEther('1'));\n    const supply = await this.APEX.totalSupply();\n    const tombRewardPoolSupply = await this.APEX.balanceOf(ApexFtmRewardPool.address);\n    const tombCirculatingSupply = supply.sub(tombRewardPoolSupply);\n    return {\n      tokenInFtm: getDisplayBalance(expectedPrice),\n      priceInDollars: getDisplayBalance(expectedPrice),\n      totalSupply: getDisplayBalance(supply, this.APEX.decimal, 0),\n      circulatingSupply: getDisplayBalance(tombCirculatingSupply, this.APEX.decimal, 0)\n    };\n  }\n\n  async getTombPriceInLastTWAP() {\n    const {\n      Treasury\n    } = this.contracts;\n    return Treasury.getApexUpdatedPrice();\n  }\n\n  async getBondsPurchasable() {\n    const {\n      Treasury\n    } = this.contracts;\n    return Treasury.getBurnableApexLeft();\n  }\n  /**\n   * Calculates the TVL, APR and daily APR of a provided pool/bank\n   * @param bank\n   * @returns\n   */\n\n\n  async getPoolAPRs(bank) {\n    if (this.myAccount === undefined) return;\n    const depositToken = bank.depositToken;\n    const poolContract = this.contracts[bank.contract];\n    const depositTokenPrice = await this.getDepositTokenPriceInDollars(bank.depositTokenName, depositToken);\n    const stakeInPool = await depositToken.balanceOf(bank.address);\n    const TVL = Number(depositTokenPrice) * Number(getDisplayBalance(stakeInPool, depositToken.decimal));\n    const stat = bank.earnTokenName === 'APEX' ? await this.getTombStat() : await this.getShareStat();\n    const tokenPerSecond = await this.getTokenPerSecond(bank.earnTokenName, bank.contract, poolContract, bank.depositTokenName);\n    const tokenPerHour = tokenPerSecond.mul(60).mul(60);\n    const totalRewardPricePerYear = Number(stat.priceInDollars) * Number(getDisplayBalance(tokenPerHour.mul(24).mul(365)));\n    const totalRewardPricePerDay = Number(stat.priceInDollars) * Number(getDisplayBalance(tokenPerHour.mul(24)));\n    const totalStakingTokenInPool = Number(depositTokenPrice) * Number(getDisplayBalance(stakeInPool, depositToken.decimal));\n    const dailyAPR = totalRewardPricePerDay / totalStakingTokenInPool * 100;\n    const yearlyAPR = totalRewardPricePerYear / totalStakingTokenInPool * 100;\n    return {\n      dailyAPR: dailyAPR.toFixed(2).toString(),\n      yearlyAPR: yearlyAPR.toFixed(2).toString(),\n      TVL: TVL.toFixed(2).toString()\n    };\n  }\n  /**\n   * Method to return the amount of tokens the pool yields per second\n   * @param earnTokenName the name of the token that the pool is earning\n   * @param contractName the contract of the pool/bank\n   * @param poolContract the actual contract of the pool\n   * @returns\n   */\n\n\n  async getTokenPerSecond(earnTokenName, contractName, poolContract, depositTokenName) {\n    if (earnTokenName === 'APEX') {\n      if (!contractName.endsWith('ApexRewardPool')) {\n        const rewardPerSecond = await poolContract.apexPerSecond();\n\n        if (depositTokenName === 'WFTM') {\n          return rewardPerSecond.mul(6000).div(11000).div(24);\n        } else if (depositTokenName === 'BOO') {\n          return rewardPerSecond.mul(2500).div(11000).div(24);\n        } else if (depositTokenName === 'ZOO') {\n          return rewardPerSecond.mul(1000).div(11000).div(24);\n        } else if (depositTokenName === 'SHIBA') {\n          return rewardPerSecond.mul(1500).div(11000).div(24);\n        }\n\n        return rewardPerSecond.div(24);\n      }\n\n      const poolStartTime = await poolContract.poolStartTime();\n      const startDateTime = new Date(poolStartTime.toNumber() * 1000);\n      const FOUR_DAYS = 4 * 24 * 60 * 60 * 1000;\n\n      if (Date.now() - startDateTime.getTime() > FOUR_DAYS) {\n        return await poolContract.epochApexPerSecond(1);\n      }\n\n      return await poolContract.epochApexPerSecond(0);\n    }\n\n    const rewardPerSecond = await poolContract.AsharePerSecond();\n\n    if (depositTokenName === 'APEX-FTM-LP') {\n      return rewardPerSecond.mul(750).div(1000);\n    } else if (depositTokenName === 'ASHARE-FTM-LP') {\n      return rewardPerSecond.mul(90).div(1000);\n    } else if (depositTokenName === 'APEX') {\n      return rewardPerSecond.mul(160).div(1000);\n    }\n  }\n  /**\n   * Method to calculate the tokenPrice of the deposited asset in a pool/bank\n   * If the deposited token is an LP it will find the price of its pieces\n   * @param tokenName\n   * @param pool\n   * @param token\n   * @returns\n   */\n\n\n  async getDepositTokenPriceInDollars(tokenName, token) {\n    let tokenPrice;\n    const priceOfOneFtmInDollars = await this.getWFTMPriceFromPancakeswap();\n\n    if (tokenName === 'WFTM') {\n      tokenPrice = priceOfOneFtmInDollars;\n    } else {\n      if (tokenName === 'APEX-FTM-LP') {\n        tokenPrice = await this.getLPTokenPrice(token, this.APEX, true);\n      } else if (tokenName === 'ASHARE-FTM-LP') {\n        tokenPrice = await this.getLPTokenPrice(token, this.ASHARE, false);\n      } else if (tokenName === 'SHIBA') {\n        tokenPrice = await this.getTokenPriceFromSpiritswap(token);\n      } else {\n        tokenPrice = await this.getTokenPriceFromPancakeswap(token);\n        tokenPrice = (Number(tokenPrice) * Number(priceOfOneFtmInDollars)).toString();\n      }\n    }\n\n    return tokenPrice;\n  } //===================================================================\n  //===================== GET ASSET STATS =============================\n  //=========================== END ===================================\n  //===================================================================\n\n\n  async getCurrentEpoch() {\n    const {\n      Treasury\n    } = this.contracts;\n    return Treasury.epoch();\n  }\n\n  async getBondOraclePriceInLastTWAP() {\n    const {\n      Treasury\n    } = this.contracts;\n    return Treasury.getBondPremiumRate();\n  }\n  /**\n   * Buy bonds with cash.\n   * @param amount amount of cash to purchase bonds with.\n   */\n\n\n  async buyBonds(amount) {\n    const {\n      Treasury\n    } = this.contracts;\n    const treasuryTombPrice = await Treasury.getApexPrice();\n    return await Treasury.buyBonds(decimalToBalance(amount), treasuryTombPrice);\n  }\n  /**\n   * Redeem bonds for cash.\n   * @param amount amount of bonds to redeem.\n   */\n\n\n  async redeemBonds(amount) {\n    const {\n      Treasury\n    } = this.contracts;\n    const priceForTomb = await Treasury.getApexPrice();\n    return await Treasury.redeemBonds(decimalToBalance(amount), priceForTomb);\n  }\n\n  async getTotalValueLocked() {\n    let totalValue = 0;\n\n    for (const bankInfo of Object.values(bankDefinitions)) {\n      const pool = this.contracts[bankInfo.contract];\n      const token = this.externalTokens[bankInfo.depositTokenName];\n      const tokenPrice = await this.getDepositTokenPriceInDollars(bankInfo.depositTokenName, token);\n      const tokenAmountInPool = await token.balanceOf(pool.address);\n      const value = Number(getDisplayBalance(tokenAmountInPool, token.decimal)) * Number(tokenPrice);\n      const poolValue = Number.isNaN(value) ? 0 : value;\n      totalValue += poolValue;\n    }\n\n    const TSHAREPrice = (await this.getShareStat()).priceInDollars;\n    const masonrytShareBalanceOf = await this.ASHARE.balanceOf(this.currentMasonry().address);\n    const masonryTVL = Number(getDisplayBalance(masonrytShareBalanceOf, this.ASHARE.decimal)) * Number(TSHAREPrice);\n    return totalValue + masonryTVL;\n  }\n  /**\n   * Calculates the price of an LP token\n   * Reference https://github.com/DefiDebauchery/discordpricebot/blob/4da3cdb57016df108ad2d0bb0c91cd8dd5f9d834/pricebot/pricebot.py#L150\n   * @param lpToken the token under calculation\n   * @param token the token pair used as reference (the other one would be FTM in most cases)\n   * @param isTomb sanity check for usage of tomb token or tShare\n   * @returns price of the LP token\n   */\n\n\n  async getLPTokenPrice(lpToken, token, isTomb) {\n    const totalSupply = getFullDisplayBalance(await lpToken.totalSupply(), lpToken.decimal); //Get amount of tokenA\n\n    const tokenSupply = getFullDisplayBalance(await token.balanceOf(lpToken.address), token.decimal);\n    const stat = isTomb === true ? await this.getTombStat() : await this.getShareStat();\n    const priceOfToken = stat.priceInDollars;\n    const tokenInLP = Number(tokenSupply) / Number(totalSupply);\n    const tokenPrice = (Number(priceOfToken) * tokenInLP * 2). //We multiply by 2 since half the price of the lp token is the price of each piece of the pair. So twice gives the total\n    toString();\n    return tokenPrice;\n  }\n\n  async earnedFromBank(poolName, earnTokenName, poolId, account = this.myAccount) {\n    const pool = this.contracts[poolName];\n\n    try {\n      if (earnTokenName === 'APEX') {\n        return await pool.pendingAPEX(poolId, account);\n      } else {\n        return await pool.pendingShare(poolId, account);\n      }\n    } catch (err) {\n      console.error(`Failed to call earned() on pool ${pool.address}: ${err.stack}`);\n      return BigNumber.from(0);\n    }\n  }\n\n  async stakedBalanceOnBank(poolName, poolId, account = this.myAccount) {\n    const pool = this.contracts[poolName];\n\n    try {\n      let userInfo = await pool.userInfo(poolId, account);\n      return await userInfo.amount;\n    } catch (err) {\n      console.error(`Failed to call balanceOf() on pool ${pool.address}: ${err.stack}`);\n      return BigNumber.from(0);\n    }\n  }\n  /**\n   * Deposits token to given pool.\n   * @param poolName A name of pool contract.\n   * @param amount Number of tokens with decimals applied. (e.g. 1.45 DAI * 10^18)\n   * @returns {string} Transaction hash\n   */\n\n\n  async stake(poolName, poolId, amount) {\n    const pool = this.contracts[poolName];\n    return await pool.deposit(poolId, amount);\n  }\n  /**\n   * Withdraws token from given pool.\n   * @param poolName A name of pool contract.\n   * @param amount Number of tokens with decimals applied. (e.g. 1.45 DAI * 10^18)\n   * @returns {string} Transaction hash\n   */\n\n\n  async unstake(poolName, poolId, amount) {\n    const pool = this.contracts[poolName];\n    return await pool.withdraw(poolId, amount);\n  }\n  /**\n   * Transfers earned token reward from given pool to my account.\n   */\n\n\n  async harvest(poolName, poolId) {\n    const pool = this.contracts[poolName]; //By passing 0 as the amount, we are asking the contract to only redeem the reward and not the currently staked token\n\n    return await pool.withdraw(poolId, 0);\n  }\n  /**\n   * Harvests and withdraws deposited tokens from the pool.\n   */\n\n\n  async exit(poolName, poolId, account = this.myAccount) {\n    const pool = this.contracts[poolName];\n    let userInfo = await pool.userInfo(poolId, account);\n    return await pool.withdraw(poolId, userInfo.amount);\n  }\n\n  async fetchMasonryVersionOfUser() {\n    return 'latest';\n  }\n\n  currentMasonry() {\n    if (!this.masonryVersionOfUser) {//throw new Error('you must unlock the wallet to continue.');\n    }\n\n    return this.contracts.Masonry;\n  }\n\n  isOldMasonryMember() {\n    return this.masonryVersionOfUser !== 'latest';\n  }\n\n  async getTokenPriceFromPancakeswap(tokenContract) {\n    const ready = await this.provider.ready;\n    if (!ready) return;\n    const {\n      chainId\n    } = this.config;\n    const {\n      WFTM\n    } = this.config.externalTokens;\n    const wftm = new Token(chainId, WFTM[0], WFTM[1]);\n    const token = new Token(chainId, tokenContract.address, tokenContract.decimal, tokenContract.symbol);\n\n    try {\n      const wftmToToken = await Fetcher.fetchPairData(wftm, token, this.provider);\n      const priceInBUSD = new Route([wftmToToken], token);\n      return priceInBUSD.midPrice.toFixed(4);\n    } catch (err) {\n      console.error(`Failed to fetch token price of ${tokenContract.symbol}: ${err}`);\n    }\n  }\n\n  async getTokenPriceFromSpiritswap(tokenContract) {\n    const ready = await this.provider.ready;\n    if (!ready) return;\n    const {\n      chainId\n    } = this.config;\n    const {\n      WFTM\n    } = this.externalTokens;\n    const wftm = new TokenSpirit(chainId, WFTM.address, WFTM.decimal);\n    const token = new TokenSpirit(chainId, tokenContract.address, tokenContract.decimal, tokenContract.symbol);\n\n    try {\n      const wftmToToken = await FetcherSpirit.fetchPairData(wftm, token, this.provider);\n      const liquidityToken = wftmToToken.liquidityToken;\n      let ftmBalanceInLP = await WFTM.balanceOf(liquidityToken.address);\n      let ftmAmount = Number(getFullDisplayBalance(ftmBalanceInLP, WFTM.decimal));\n      let shibaBalanceInLP = await tokenContract.balanceOf(liquidityToken.address);\n      let shibaAmount = Number(getFullDisplayBalance(shibaBalanceInLP, tokenContract.decimal));\n      const priceOfOneFtmInDollars = await this.getWFTMPriceFromPancakeswap();\n      let priceOfShiba = ftmAmount / shibaAmount * Number(priceOfOneFtmInDollars);\n      return priceOfShiba.toString();\n    } catch (err) {\n      console.error(`Failed to fetch token price of ${tokenContract.symbol}: ${err}`);\n    }\n  }\n\n  async getWFTMPriceFromPancakeswap() {\n    const ready = await this.provider.ready;\n    if (!ready) return;\n    const {\n      WFTM,\n      FUSDT\n    } = this.externalTokens;\n\n    try {\n      const fusdt_wftm_lp_pair = this.externalTokens['USDT-FTM-LP'];\n      let ftm_amount_BN = await WFTM.balanceOf(fusdt_wftm_lp_pair.address);\n      let ftm_amount = Number(getFullDisplayBalance(ftm_amount_BN, WFTM.decimal));\n      let fusdt_amount_BN = await FUSDT.balanceOf(fusdt_wftm_lp_pair.address);\n      let fusdt_amount = Number(getFullDisplayBalance(fusdt_amount_BN, FUSDT.decimal));\n      return (fusdt_amount / ftm_amount).toString();\n    } catch (err) {\n      console.error(`Failed to fetch token price of WFTM: ${err}`);\n    }\n  } //===================================================================\n  //===================================================================\n  //===================== MASONRY METHODS =============================\n  //===================================================================\n  //===================================================================\n\n\n  async getMasonryAPR() {\n    const Masonry = this.currentMasonry();\n    const latestSnapshotIndex = await Masonry.latestSnapshotIndex();\n    const lastHistory = await Masonry.boardroomHistory(latestSnapshotIndex);\n    const lastRewardsReceived = lastHistory[1];\n    const TSHAREPrice = (await this.getShareStat()).priceInDollars;\n    const TOMBPrice = (await this.getTombStat()).priceInDollars;\n    const epochRewardsPerShare = lastRewardsReceived / 1e18; //Mgod formula\n\n    const amountOfRewardsPerDay = epochRewardsPerShare * Number(TOMBPrice) * 4;\n    const masonrytShareBalanceOf = await this.ASHARE.balanceOf(Masonry.address);\n    const masonryTVL = Number(getDisplayBalance(masonrytShareBalanceOf, this.ASHARE.decimal)) * Number(TSHAREPrice);\n    const realAPR = amountOfRewardsPerDay * 100 / masonryTVL * 365;\n    return realAPR;\n  }\n  /**\n   * Checks if the user is allowed to retrieve their reward from the Masonry\n   * @returns true if user can withdraw reward, false if they can't\n   */\n\n\n  async canUserClaimRewardFromMasonry() {\n    const Masonry = this.currentMasonry();\n    return await Masonry.canClaimReward(this.myAccount);\n  }\n  /**\n   * Checks if the user is allowed to retrieve their reward from the Masonry\n   * @returns true if user can withdraw reward, false if they can't\n   */\n\n\n  async canUserUnstakeFromMasonry() {\n    const Masonry = this.currentMasonry();\n    const canWithdraw = await Masonry.canWithdraw(this.myAccount);\n    const stakedAmount = await this.getStakedSharesOnMasonry();\n    const notStaked = Number(getDisplayBalance(stakedAmount, this.ASHARE.decimal)) === 0;\n    const result = notStaked ? true : canWithdraw;\n    return result;\n  }\n\n  async timeUntilClaimRewardFromMasonry() {\n    // const Masonry = this.currentMasonry();\n    // const mason = await Masonry.masons(this.myAccount);\n    return BigNumber.from(0);\n  }\n\n  async getTotalStakedInMasonry() {\n    const Masonry = this.currentMasonry();\n    return await Masonry.totalSupply();\n  }\n\n  async stakeShareToMasonry(amount) {\n    if (this.isOldMasonryMember()) {\n      throw new Error(\"you're using old masonry. please withdraw and deposit the ASHARE again.\");\n    }\n\n    const Masonry = this.currentMasonry();\n    return await Masonry.stake(decimalToBalance(amount));\n  }\n\n  async getStakedSharesOnMasonry() {\n    const Masonry = this.currentMasonry();\n\n    if (this.masonryVersionOfUser === 'v1') {\n      return await Masonry.getShareOf(this.myAccount);\n    }\n\n    return await Masonry.balanceOf(this.myAccount);\n  }\n\n  async getEarningsOnMasonry() {\n    const Masonry = this.currentMasonry();\n\n    if (this.masonryVersionOfUser === 'v1') {\n      return await Masonry.getCashEarningsOf(this.myAccount);\n    }\n\n    return await Masonry.earned(this.myAccount);\n  }\n\n  async withdrawShareFromMasonry(amount) {\n    const Masonry = this.currentMasonry();\n    return await Masonry.withdraw(decimalToBalance(amount));\n  }\n\n  async harvestCashFromMasonry() {\n    const Masonry = this.currentMasonry();\n\n    if (this.masonryVersionOfUser === 'v1') {\n      return await Masonry.claimDividends();\n    }\n\n    return await Masonry.claimReward();\n  }\n\n  async exitFromMasonry() {\n    const Masonry = this.currentMasonry();\n    return await Masonry.exit();\n  }\n\n  async allocateSeigniorage() {\n    const {\n      Treasury\n    } = this.contracts;\n    return await Treasury.allocateSeigniorage();\n  }\n\n  async getTreasuryNextAllocationTime() {\n    const {\n      Treasury\n    } = this.contracts;\n    const nextEpochTimestamp = await Treasury.nextEpochPoint();\n    const nextAllocation = new Date(nextEpochTimestamp.mul(1000).toNumber());\n    const prevAllocation = new Date(Date.now());\n    return {\n      from: prevAllocation,\n      to: nextAllocation\n    };\n  }\n  /**\n   * This method calculates and returns in a from to to format\n   * the period the user needs to wait before being allowed to claim\n   * their reward from the masonry\n   * @returns Promise<AllocationTime>\n   */\n\n\n  async getUserClaimRewardTime() {\n    const {\n      Masonry,\n      Treasury\n    } = this.contracts;\n    const nextEpochTimestamp = await Masonry.nextEpochPoint(); //in unix timestamp\n\n    const currentEpoch = await Masonry.epoch();\n    const mason = await Masonry.boards(this.myAccount);\n    const startTimeEpoch = mason.epochTimerStart;\n    const period = await Treasury.PERIOD();\n    const periodInHours = period / 60 / 60; // 6 hours, period is displayed in seconds which is 21600\n\n    const rewardLockupEpochs = await Masonry.rewardLockupEpochs();\n    const targetEpochForClaimUnlock = Number(startTimeEpoch) + Number(rewardLockupEpochs);\n    const fromDate = new Date(Date.now());\n\n    if (targetEpochForClaimUnlock - currentEpoch <= 0) {\n      return {\n        from: fromDate,\n        to: fromDate\n      };\n    } else if (targetEpochForClaimUnlock - currentEpoch === 1) {\n      const toDate = new Date(nextEpochTimestamp * 1000);\n      return {\n        from: fromDate,\n        to: toDate\n      };\n    } else {\n      const toDate = new Date(nextEpochTimestamp * 1000);\n      const delta = targetEpochForClaimUnlock - currentEpoch - 1;\n      const endDate = moment(toDate).add(delta * periodInHours, 'hours').toDate();\n      return {\n        from: fromDate,\n        to: endDate\n      };\n    }\n  }\n  /**\n   * This method calculates and returns in a from to to format\n   * the period the user needs to wait before being allowed to unstake\n   * from the masonry\n   * @returns Promise<AllocationTime>\n   */\n\n\n  async getUserUnstakeTime() {\n    const {\n      Masonry,\n      Treasury\n    } = this.contracts;\n    const nextEpochTimestamp = await Masonry.nextEpochPoint();\n    const currentEpoch = await Masonry.epoch();\n    const mason = await Masonry.boards(this.myAccount);\n    const startTimeEpoch = mason.epochTimerStart;\n    const period = await Treasury.PERIOD();\n    const PeriodInHours = period / 60 / 60;\n    const withdrawLockupEpochs = await Masonry.withdrawLockupEpochs();\n    const fromDate = new Date(Date.now());\n    const targetEpochForClaimUnlock = Number(startTimeEpoch) + Number(withdrawLockupEpochs);\n    const stakedAmount = await this.getStakedSharesOnMasonry();\n\n    if (currentEpoch <= targetEpochForClaimUnlock && Number(stakedAmount) === 0) {\n      return {\n        from: fromDate,\n        to: fromDate\n      };\n    } else if (targetEpochForClaimUnlock - currentEpoch === 1) {\n      const toDate = new Date(nextEpochTimestamp * 1000);\n      return {\n        from: fromDate,\n        to: toDate\n      };\n    } else {\n      const toDate = new Date(nextEpochTimestamp * 1000);\n      const delta = targetEpochForClaimUnlock - Number(currentEpoch) - 1;\n      const endDate = moment(toDate).add(delta * PeriodInHours, 'hours').toDate();\n      return {\n        from: fromDate,\n        to: endDate\n      };\n    }\n  }\n\n  async watchAssetInMetamask(assetName) {\n    const {\n      ethereum\n    } = window;\n\n    if (ethereum && ethereum.networkVersion === config.chainId.toString()) {\n      let asset;\n      let assetUrl;\n\n      if (assetName === 'APEX') {\n        asset = this.APEX;\n        assetUrl = 'https://tomb.finance/presskit/tomb_icon_noBG.png';\n      } else if (assetName === 'ASHARE') {\n        asset = this.ASHARE;\n        assetUrl = 'https://tomb.finance/presskit/tshare_icon_noBG.png';\n      } else if (assetName === 'ABOND') {\n        asset = this.ABOND;\n        assetUrl = 'https://tomb.finance/presskit/tbond_icon_noBG.png';\n      }\n\n      await ethereum.request({\n        method: 'wallet_watchAsset',\n        params: {\n          type: 'ERC20',\n          options: {\n            address: asset.address,\n            symbol: asset.symbol,\n            decimals: 18,\n            image: assetUrl\n          }\n        }\n      });\n    }\n\n    return true;\n  }\n\n  async provideTombFtmLP(ftmAmount, tombAmount) {\n    const {\n      TaxOffice\n    } = this.contracts;\n    let overrides = {\n      value: parseUnits(ftmAmount, 18)\n    };\n    return await TaxOffice.addLiquidityETHTaxFree(tombAmount, tombAmount.mul(992).div(1000), parseUnits(ftmAmount, 18).mul(992).div(1000), overrides);\n  }\n\n  async quoteFromSpooky(tokenAmount, tokenName) {\n    const {\n      SpookyRouter\n    } = this.contracts;\n    const {\n      _reserve0,\n      _reserve1\n    } = await this.TOMBWFTM_LP.getReserves();\n    let quote;\n\n    if (tokenName === 'APEX') {\n      quote = await SpookyRouter.quote(parseUnits(tokenAmount), _reserve1, _reserve0);\n    } else {\n      quote = await SpookyRouter.quote(parseUnits(tokenAmount), _reserve0, _reserve1);\n    }\n\n    return (quote / 1e18).toString();\n  }\n  /**\n   * @returns an array of the regulation events till the most up to date epoch\n   */\n\n\n  async listenForRegulationsEvents() {\n    const {\n      Treasury\n    } = this.contracts;\n    const treasuryDaoFundedFilter = Treasury.filters.DaoFundFunded();\n    const treasuryDevFundedFilter = Treasury.filters.DevFundFunded();\n    const treasuryMasonryFundedFilter = Treasury.filters.MasonryFunded();\n    const boughtBondsFilter = Treasury.filters.BoughtBonds();\n    const redeemBondsFilter = Treasury.filters.RedeemedBonds();\n    let epochBlocksRanges = [];\n    let masonryFundEvents = await Treasury.queryFilter(treasuryMasonryFundedFilter);\n    var events = [];\n    masonryFundEvents.forEach(function callback(value, index) {\n      events.push({\n        epoch: index + 1\n      });\n      events[index].masonryFund = getDisplayBalance(value.args[1]);\n\n      if (index === 0) {\n        epochBlocksRanges.push({\n          index: index,\n          startBlock: value.blockNumber,\n          boughBonds: 0,\n          redeemedBonds: 0\n        });\n      }\n\n      if (index > 0) {\n        epochBlocksRanges.push({\n          index: index,\n          startBlock: value.blockNumber,\n          boughBonds: 0,\n          redeemedBonds: 0\n        });\n        epochBlocksRanges[index - 1].endBlock = value.blockNumber;\n      }\n    });\n    epochBlocksRanges.forEach(async (value, index) => {\n      events[index].bondsBought = await this.getBondsWithFilterForPeriod(boughtBondsFilter, value.startBlock, value.endBlock);\n      events[index].bondsRedeemed = await this.getBondsWithFilterForPeriod(redeemBondsFilter, value.startBlock, value.endBlock);\n    });\n    let DEVFundEvents = await Treasury.queryFilter(treasuryDevFundedFilter);\n    DEVFundEvents.forEach(function callback(value, index) {\n      events[index].devFund = getDisplayBalance(value.args[1]);\n    });\n    let DAOFundEvents = await Treasury.queryFilter(treasuryDaoFundedFilter);\n    DAOFundEvents.forEach(function callback(value, index) {\n      events[index].daoFund = getDisplayBalance(value.args[1]);\n    });\n    return events;\n  }\n  /**\n   * Helper method\n   * @param filter applied on the query to the treasury events\n   * @param from block number\n   * @param to block number\n   * @returns the amount of bonds events emitted based on the filter provided during a specific period\n   */\n\n\n  async getBondsWithFilterForPeriod(filter, from, to) {\n    const {\n      Treasury\n    } = this.contracts;\n    const bondsAmount = await Treasury.queryFilter(filter, from, to);\n    return bondsAmount.length;\n  }\n\n  async estimateZapIn(tokenName, lpName, amount) {\n    const {\n      zapper\n    } = this.contracts;\n    const lpToken = this.externalTokens[lpName];\n    let estimate;\n\n    if (tokenName === FTM_TICKER) {\n      estimate = await zapper.estimateZapIn(lpToken.address, SPOOKY_ROUTER_ADDR, parseUnits(amount, 18));\n    } else {\n      const token = tokenName === TOMB_TICKER ? this.APEX : this.ASHARE;\n      estimate = await zapper.estimateZapInToken(token.address, lpToken.address, SPOOKY_ROUTER_ADDR, parseUnits(amount, 18));\n    }\n\n    return [estimate[0] / 1e18, estimate[1] / 1e18];\n  }\n\n  async zapIn(tokenName, lpName, amount) {\n    const {\n      zapper\n    } = this.contracts;\n    const lpToken = this.externalTokens[lpName];\n\n    if (tokenName === FTM_TICKER) {\n      let overrides = {\n        value: parseUnits(amount, 18)\n      };\n      return await zapper.zapIn(lpToken.address, SPOOKY_ROUTER_ADDR, this.myAccount, overrides);\n    } else {\n      const token = tokenName === TOMB_TICKER ? this.APEX : this.ASHARE;\n      return await zapper.zapInToken(token.address, parseUnits(amount, 18), lpToken.address, SPOOKY_ROUTER_ADDR, this.myAccount);\n    }\n  }\n\n  async swapTBondToTShare(tbondAmount) {\n    const {\n      TShareSwapper\n    } = this.contracts;\n    return await TShareSwapper.swapTBondToTShare(tbondAmount);\n  }\n\n  async estimateAmountOfTShare(tbondAmount) {\n    const {\n      TShareSwapper\n    } = this.contracts;\n\n    try {\n      const estimateBN = await TShareSwapper.estimateAmountOfTShare(parseUnits(tbondAmount, 18));\n      return getDisplayBalance(estimateBN, 18, 6);\n    } catch (err) {\n      console.error(`Failed to fetch estimate tshare amount: ${err}`);\n    }\n  }\n\n  async getTShareSwapperStat(address) {\n    const {\n      TShareSwapper\n    } = this.contracts;\n    const tshareBalanceBN = await TShareSwapper.getTShareBalance();\n    const tbondBalanceBN = await TShareSwapper.getTBondBalance(address); // const tombPriceBN = await TShareSwapper.getTombPrice();\n    // const tsharePriceBN = await TShareSwapper.getTSharePrice();\n\n    const rateTSharePerTombBN = await TShareSwapper.getTShareAmountPerTomb();\n    const tshareBalance = getDisplayBalance(tshareBalanceBN, 18, 5);\n    const tbondBalance = getDisplayBalance(tbondBalanceBN, 18, 5);\n    return {\n      tshareBalance: tshareBalance.toString(),\n      tbondBalance: tbondBalance.toString(),\n      // tombPrice: tombPriceBN.toString(),\n      // tsharePrice: tsharePriceBN.toString(),\n      rateTSharePerTomb: rateTSharePerTombBN.toString()\n    };\n  }\n\n}","map":{"version":3,"sources":["/Users/eduarddriessen/Documents/GitHub/apx/src/tomb-finance/TombFinance.ts"],"names":["Fetcher","FetcherSpirit","Token","TokenSpirit","Route","BigNumber","Contract","ethers","decimalToBalance","ERC20","getFullDisplayBalance","getDisplayBalance","getDefaultProvider","IUniswapV2PairABI","config","bankDefinitions","moment","parseUnits","FTM_TICKER","SPOOKY_ROUTER_ADDR","TOMB_TICKER","TombFinance","constructor","cfg","myAccount","provider","signer","contracts","externalTokens","masonryVersionOfUser","TOMBWFTM_LP","APEX","ASHARE","ABOND","FTM","deployments","name","deployment","Object","entries","address","abi","symbol","decimal","tomb","tShare","tBond","unlockWallet","account","newProvider","providers","Web3Provider","chainId","getSigner","contract","connect","tokens","values","token","console","log","fetchMasonryVersionOfUser","then","version","catch","err","error","stack","isUnlocked","getTombStat","ApexFtmRewardPool","ApexFtmLPApexRewardPool","ApexFtmLPApexRewardPoolOld","supply","totalSupply","tombRewardPoolSupply","balanceOf","tombRewardPoolSupply2","tombCirculatingSupply","sub","priceInFTM","getTokenPriceFromPancakeswap","priceOfOneFTM","getWFTMPriceFromPancakeswap","priceOfTombInDollars","Number","toFixed","tokenInFtm","priceInDollars","circulatingSupply","getLPStat","lpToken","lpTokenSupplyBN","lpTokenSupply","token0","startsWith","isTomb","tokenAmountBN","tokenAmount","ftmAmountBN","ftmAmount","tokenAmountInOneLP","ftmAmountInOneLP","lpTokenPrice","getLPTokenPrice","lpTokenPriceFixed","toString","liquidity","priceOfOne","totalLiquidity","getBondStat","Treasury","tombStat","bondTombRatioBN","getBondPremiumRate","modifier","bondPriceInFTM","priceOfTBondInDollars","displayedTotalSupply","getShareStat","ApexFtmLPAShareRewardPool","tShareCirculatingSupply","priceOfSharesInDollars","getTombStatInEstimatedTWAP","SeigniorageOracle","expectedPrice","twap","utils","parseEther","getTombPriceInLastTWAP","getApexUpdatedPrice","getBondsPurchasable","getBurnableApexLeft","getPoolAPRs","bank","undefined","depositToken","poolContract","depositTokenPrice","getDepositTokenPriceInDollars","depositTokenName","stakeInPool","TVL","stat","earnTokenName","tokenPerSecond","getTokenPerSecond","tokenPerHour","mul","totalRewardPricePerYear","totalRewardPricePerDay","totalStakingTokenInPool","dailyAPR","yearlyAPR","contractName","endsWith","rewardPerSecond","apexPerSecond","div","poolStartTime","startDateTime","Date","toNumber","FOUR_DAYS","now","getTime","epochApexPerSecond","AsharePerSecond","tokenName","tokenPrice","priceOfOneFtmInDollars","getTokenPriceFromSpiritswap","getCurrentEpoch","epoch","getBondOraclePriceInLastTWAP","buyBonds","amount","treasuryTombPrice","getApexPrice","redeemBonds","priceForTomb","getTotalValueLocked","totalValue","bankInfo","pool","tokenAmountInPool","value","poolValue","isNaN","TSHAREPrice","masonrytShareBalanceOf","currentMasonry","masonryTVL","tokenSupply","priceOfToken","tokenInLP","earnedFromBank","poolName","poolId","pendingAPEX","pendingShare","from","stakedBalanceOnBank","userInfo","stake","deposit","unstake","withdraw","harvest","exit","Masonry","isOldMasonryMember","tokenContract","ready","WFTM","wftm","wftmToToken","fetchPairData","priceInBUSD","midPrice","liquidityToken","ftmBalanceInLP","shibaBalanceInLP","shibaAmount","priceOfShiba","FUSDT","fusdt_wftm_lp_pair","ftm_amount_BN","ftm_amount","fusdt_amount_BN","fusdt_amount","getMasonryAPR","latestSnapshotIndex","lastHistory","boardroomHistory","lastRewardsReceived","TOMBPrice","epochRewardsPerShare","amountOfRewardsPerDay","realAPR","canUserClaimRewardFromMasonry","canClaimReward","canUserUnstakeFromMasonry","canWithdraw","stakedAmount","getStakedSharesOnMasonry","notStaked","result","timeUntilClaimRewardFromMasonry","getTotalStakedInMasonry","stakeShareToMasonry","Error","getShareOf","getEarningsOnMasonry","getCashEarningsOf","earned","withdrawShareFromMasonry","harvestCashFromMasonry","claimDividends","claimReward","exitFromMasonry","allocateSeigniorage","getTreasuryNextAllocationTime","nextEpochTimestamp","nextEpochPoint","nextAllocation","prevAllocation","to","getUserClaimRewardTime","currentEpoch","mason","boards","startTimeEpoch","epochTimerStart","period","PERIOD","periodInHours","rewardLockupEpochs","targetEpochForClaimUnlock","fromDate","toDate","delta","endDate","add","getUserUnstakeTime","PeriodInHours","withdrawLockupEpochs","watchAssetInMetamask","assetName","ethereum","window","networkVersion","asset","assetUrl","request","method","params","type","options","decimals","image","provideTombFtmLP","tombAmount","TaxOffice","overrides","addLiquidityETHTaxFree","quoteFromSpooky","SpookyRouter","_reserve0","_reserve1","getReserves","quote","listenForRegulationsEvents","treasuryDaoFundedFilter","filters","DaoFundFunded","treasuryDevFundedFilter","DevFundFunded","treasuryMasonryFundedFilter","MasonryFunded","boughtBondsFilter","BoughtBonds","redeemBondsFilter","RedeemedBonds","epochBlocksRanges","masonryFundEvents","queryFilter","events","forEach","callback","index","push","masonryFund","args","startBlock","blockNumber","boughBonds","redeemedBonds","endBlock","bondsBought","getBondsWithFilterForPeriod","bondsRedeemed","DEVFundEvents","devFund","DAOFundEvents","daoFund","filter","bondsAmount","length","estimateZapIn","lpName","zapper","estimate","estimateZapInToken","zapIn","zapInToken","swapTBondToTShare","tbondAmount","TShareSwapper","estimateAmountOfTShare","estimateBN","getTShareSwapperStat","tshareBalanceBN","getTShareBalance","tbondBalanceBN","getTBondBalance","rateTSharePerTombBN","getTShareAmountPerTomb","tshareBalance","tbondBalance","rateTSharePerTomb"],"mappings":"AAAA;AACA,SAASA,OAAO,IAAIC,aAApB,EAAmCC,KAAK,IAAIC,WAA5C,QAA+D,iBAA/D;AACA,SAASH,OAAT,EAAkBI,KAAlB,EAAyBF,KAAzB,QAAsC,iBAAtC;AAGA,SAASG,SAAT,EAAoBC,QAApB,EAA8BC,MAA9B,QAAyD,QAAzD;AACA,SAASC,gBAAT,QAAiC,eAAjC;AAEA,OAAOC,KAAP,MAAkB,SAAlB;AACA,SAASC,qBAAT,EAAgCC,iBAAhC,QAAyD,wBAAzD;AACA,SAASC,kBAAT,QAAmC,mBAAnC;AACA,OAAOC,iBAAP,MAA8B,2BAA9B;AACA,OAAOC,MAAP,IAAiBC,eAAjB,QAAwC,WAAxC;AACA,OAAOC,MAAP,MAAmB,QAAnB;AACA,SAASC,UAAT,QAA2B,kBAA3B;AACA,SAASC,UAAT,EAAqBC,kBAArB,EAAyCC,WAAzC,QAA4D,oBAA5D;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,WAAN,CAAkB;AAevBC,EAAAA,WAAW,CAACC,GAAD,EAAqB;AAAA,SAdhCC,SAcgC;AAAA,SAbhCC,QAagC;AAAA,SAZhCC,MAYgC;AAAA,SAXhCZ,MAWgC;AAAA,SAVhCa,SAUgC;AAAA,SAThCC,cASgC;AAAA,SARhCC,oBAQgC;AAAA,SANhCC,WAMgC;AAAA,SALhCC,IAKgC;AAAA,SAJhCC,MAIgC;AAAA,SAHhCC,KAGgC;AAAA,SAFhCC,GAEgC;AAC9B,UAAM;AAAEC,MAAAA,WAAF;AAAeP,MAAAA;AAAf,QAAkCL,GAAxC;AACA,UAAME,QAAQ,GAAGb,kBAAkB,EAAnC,CAF8B,CAI9B;;AACA,SAAKe,SAAL,GAAiB,EAAjB;;AACA,SAAK,MAAM,CAACS,IAAD,EAAOC,UAAP,CAAX,IAAiCC,MAAM,CAACC,OAAP,CAAeJ,WAAf,CAAjC,EAA8D;AAC5D,WAAKR,SAAL,CAAeS,IAAf,IAAuB,IAAI9B,QAAJ,CAAa+B,UAAU,CAACG,OAAxB,EAAiCH,UAAU,CAACI,GAA5C,EAAiDhB,QAAjD,CAAvB;AACD;;AACD,SAAKG,cAAL,GAAsB,EAAtB;;AACA,SAAK,MAAM,CAACc,MAAD,EAAS,CAACF,OAAD,EAAUG,OAAV,CAAT,CAAX,IAA2CL,MAAM,CAACC,OAAP,CAAeX,cAAf,CAA3C,EAA2E;AACzE,WAAKA,cAAL,CAAoBc,MAApB,IAA8B,IAAIjC,KAAJ,CAAU+B,OAAV,EAAmBf,QAAnB,EAA6BiB,MAA7B,EAAqCC,OAArC,CAA9B;AACD;;AACD,SAAKZ,IAAL,GAAY,IAAItB,KAAJ,CAAU0B,WAAW,CAACS,IAAZ,CAAiBJ,OAA3B,EAAoCf,QAApC,EAA8C,MAA9C,CAAZ;AACA,SAAKO,MAAL,GAAc,IAAIvB,KAAJ,CAAU0B,WAAW,CAACU,MAAZ,CAAmBL,OAA7B,EAAsCf,QAAtC,EAAgD,QAAhD,CAAd;AACA,SAAKQ,KAAL,GAAa,IAAIxB,KAAJ,CAAU0B,WAAW,CAACW,KAAZ,CAAkBN,OAA5B,EAAqCf,QAArC,EAA+C,OAA/C,CAAb;AACA,SAAKS,GAAL,GAAW,KAAKN,cAAL,CAAoB,MAApB,CAAX,CAhB8B,CAkB9B;;AACA,SAAKE,WAAL,GAAmB,IAAIxB,QAAJ,CAAasB,cAAc,CAAC,aAAD,CAAd,CAA8B,CAA9B,CAAb,EAA+Cf,iBAA/C,EAAkEY,QAAlE,CAAnB;AAEA,SAAKX,MAAL,GAAcS,GAAd;AACA,SAAKE,QAAL,GAAgBA,QAAhB;AACD;AAED;AACF;AACA;AACA;;;AACEsB,EAAAA,YAAY,CAACtB,QAAD,EAAgBuB,OAAhB,EAAiC;AAC3C,UAAMC,WAAW,GAAG,IAAI1C,MAAM,CAAC2C,SAAP,CAAiBC,YAArB,CAAkC1B,QAAlC,EAA4C,KAAKX,MAAL,CAAYsC,OAAxD,CAApB;AACA,SAAK1B,MAAL,GAAcuB,WAAW,CAACI,SAAZ,CAAsB,CAAtB,CAAd;AACA,SAAK7B,SAAL,GAAiBwB,OAAjB;;AACA,SAAK,MAAM,CAACZ,IAAD,EAAOkB,QAAP,CAAX,IAA+BhB,MAAM,CAACC,OAAP,CAAe,KAAKZ,SAApB,CAA/B,EAA+D;AAC7D,WAAKA,SAAL,CAAeS,IAAf,IAAuBkB,QAAQ,CAACC,OAAT,CAAiB,KAAK7B,MAAtB,CAAvB;AACD;;AACD,UAAM8B,MAAM,GAAG,CAAC,KAAKzB,IAAN,EAAY,KAAKC,MAAjB,EAAyB,KAAKC,KAA9B,EAAqC,GAAGK,MAAM,CAACmB,MAAP,CAAc,KAAK7B,cAAnB,CAAxC,CAAf;;AACA,SAAK,MAAM8B,KAAX,IAAoBF,MAApB,EAA4B;AAC1BE,MAAAA,KAAK,CAACH,OAAN,CAAc,KAAK7B,MAAnB;AACD;;AACD,SAAKI,WAAL,GAAmB,KAAKA,WAAL,CAAiByB,OAAjB,CAAyB,KAAK7B,MAA9B,CAAnB;AACAiC,IAAAA,OAAO,CAACC,GAAR,CAAa,mCAAkCZ,OAAQ,GAAvD;AACA,SAAKa,yBAAL,GACGC,IADH,CACSC,OAAD,IAAc,KAAKlC,oBAAL,GAA4BkC,OADlD,EAEGC,KAFH,CAEUC,GAAD,IAAS;AACdN,MAAAA,OAAO,CAACO,KAAR,CAAe,oCAAmCD,GAAG,CAACE,KAAM,EAA5D;AACA,WAAKtC,oBAAL,GAA4B,QAA5B;AACD,KALH;AAMD;;AAEa,MAAVuC,UAAU,GAAY;AACxB,WAAO,CAAC,CAAC,KAAK5C,SAAd;AACD,GAnEsB,CAqEvB;AACA;AACA;AACA;AACA;;;AAEiB,QAAX6C,WAAW,GAAuB;AACtC,UAAM;AAAEC,MAAAA,iBAAF;AAAqBC,MAAAA,uBAArB;AAA8CC,MAAAA;AAA9C,QAA6E,KAAK7C,SAAxF;AACA,UAAM8C,MAAM,GAAG,MAAM,KAAK1C,IAAL,CAAU2C,WAAV,EAArB;AACA,UAAMC,oBAAoB,GAAG,MAAM,KAAK5C,IAAL,CAAU6C,SAAV,CAAoBN,iBAAiB,CAAC9B,OAAtC,CAAnC;AACA,UAAMqC,qBAAqB,GAAG,MAAM,KAAK9C,IAAL,CAAU6C,SAAV,CAAoBL,uBAAuB,CAAC/B,OAA5C,CAApC,CAJsC,CAKtC;;AACA,UAAMsC,qBAAqB,GAAGL,MAAM,CACjCM,GAD2B,CACvBJ,oBADuB,EAE3BI,GAF2B,CAEvBF,qBAFuB,CAA9B,CANsC,CASpC;;AACF,UAAMG,UAAU,GAAG,MAAM,KAAKC,4BAAL,CAAkC,KAAKlD,IAAvC,CAAzB;AACA,UAAMmD,aAAa,GAAG,MAAM,KAAKC,2BAAL,EAA5B;AACA,UAAMC,oBAAoB,GAAG,CAACC,MAAM,CAACL,UAAD,CAAN,GAAqBK,MAAM,CAACH,aAAD,CAA5B,EAA6CI,OAA7C,CAAqD,CAArD,CAA7B;AAEA,WAAO;AACLC,MAAAA,UAAU,EAAEP,UADP;AAELQ,MAAAA,cAAc,EAAEJ,oBAFX;AAGLV,MAAAA,WAAW,EAAE/D,iBAAiB,CAAC8D,MAAD,EAAS,KAAK1C,IAAL,CAAUY,OAAnB,EAA4B,CAA5B,CAHzB;AAIL8C,MAAAA,iBAAiB,EAAE9E,iBAAiB,CAACmE,qBAAD,EAAwB,KAAK/C,IAAL,CAAUY,OAAlC,EAA2C,CAA3C;AAJ/B,KAAP;AAMD;AAED;AACF;AACA;AACA;AACA;;;AACiB,QAAT+C,SAAS,CAACtD,IAAD,EAAgC;AAC7C,UAAMuD,OAAO,GAAG,KAAK/D,cAAL,CAAoBQ,IAApB,CAAhB;AACA,UAAMwD,eAAe,GAAG,MAAMD,OAAO,CAACjB,WAAR,EAA9B;AACA,UAAMmB,aAAa,GAAGlF,iBAAiB,CAACiF,eAAD,EAAkB,EAAlB,CAAvC;AACA,UAAME,MAAM,GAAG1D,IAAI,CAAC2D,UAAL,CAAgB,MAAhB,IAA0B,KAAKhE,IAA/B,GAAsC,KAAKC,MAA1D;AACA,UAAMgE,MAAM,GAAG5D,IAAI,CAAC2D,UAAL,CAAgB,MAAhB,CAAf;AACA,UAAME,aAAa,GAAG,MAAMH,MAAM,CAAClB,SAAP,CAAiBe,OAAO,CAACnD,OAAzB,CAA5B;AACA,UAAM0D,WAAW,GAAGvF,iBAAiB,CAACsF,aAAD,EAAgB,EAAhB,CAArC;AAEA,UAAME,WAAW,GAAG,MAAM,KAAKjE,GAAL,CAAS0C,SAAT,CAAmBe,OAAO,CAACnD,OAA3B,CAA1B;AACA,UAAM4D,SAAS,GAAGzF,iBAAiB,CAACwF,WAAD,EAAc,EAAd,CAAnC;AACA,UAAME,kBAAkB,GAAGhB,MAAM,CAACa,WAAD,CAAN,GAAsBb,MAAM,CAACQ,aAAD,CAAvD;AACA,UAAMS,gBAAgB,GAAGjB,MAAM,CAACe,SAAD,CAAN,GAAoBf,MAAM,CAACQ,aAAD,CAAnD;AACA,UAAMU,YAAY,GAAG,MAAM,KAAKC,eAAL,CAAqBb,OAArB,EAA8BG,MAA9B,EAAsCE,MAAtC,CAA3B;AACA,UAAMS,iBAAiB,GAAGpB,MAAM,CAACkB,YAAD,CAAN,CAAqBjB,OAArB,CAA6B,CAA7B,EAAgCoB,QAAhC,EAA1B;AACA,UAAMC,SAAS,GAAG,CAACtB,MAAM,CAACQ,aAAD,CAAN,GAAwBR,MAAM,CAACkB,YAAD,CAA/B,EAA+CjB,OAA/C,CAAuD,CAAvD,EAA0DoB,QAA1D,EAAlB;AACA,WAAO;AACLR,MAAAA,WAAW,EAAEG,kBAAkB,CAACf,OAAnB,CAA2B,CAA3B,EAA8BoB,QAA9B,EADR;AAELN,MAAAA,SAAS,EAAEE,gBAAgB,CAAChB,OAAjB,CAAyB,CAAzB,EAA4BoB,QAA5B,EAFN;AAGLE,MAAAA,UAAU,EAAEH,iBAHP;AAILI,MAAAA,cAAc,EAAEF,SAJX;AAKLjC,MAAAA,WAAW,EAAEW,MAAM,CAACQ,aAAD,CAAN,CAAsBP,OAAtB,CAA8B,CAA9B,EAAiCoB,QAAjC;AALR,KAAP;AAOD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACmB,QAAXI,WAAW,GAAuB;AACtC,UAAM;AAAEC,MAAAA;AAAF,QAAe,KAAKpF,SAA1B;AACA,UAAMqF,QAAQ,GAAG,MAAM,KAAK3C,WAAL,EAAvB;AACA,UAAM4C,eAAe,GAAG,MAAMF,QAAQ,CAACG,kBAAT,EAA9B;AACA,UAAMC,QAAQ,GAAGF,eAAe,GAAG,IAAlB,GAAyB,CAAzB,GAA6BA,eAAe,GAAG,IAA/C,GAAsD,CAAvE;AACA,UAAMG,cAAc,GAAG,CAAC/B,MAAM,CAAC2B,QAAQ,CAACzB,UAAV,CAAN,GAA8B4B,QAA/B,EAAyC7B,OAAzC,CAAiD,CAAjD,CAAvB;AACA,UAAM+B,qBAAqB,GAAG,CAAChC,MAAM,CAAC2B,QAAQ,CAACxB,cAAV,CAAN,GAAkC2B,QAAnC,EAA6C7B,OAA7C,CAAqD,CAArD,CAA9B;AACA,UAAMb,MAAM,GAAG,MAAM,KAAKxC,KAAL,CAAWqF,oBAAX,EAArB;AACA,WAAO;AACL/B,MAAAA,UAAU,EAAE6B,cADP;AAEL5B,MAAAA,cAAc,EAAE6B,qBAFX;AAGL3C,MAAAA,WAAW,EAAED,MAHR;AAILgB,MAAAA,iBAAiB,EAAEhB;AAJd,KAAP;AAMD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACoB,QAAZ8C,YAAY,GAAuB;AACvC,UAAM;AAAEC,MAAAA;AAAF,QAAgC,KAAK7F,SAA3C;AAEA,UAAM8C,MAAM,GAAG,MAAM,KAAKzC,MAAL,CAAY0C,WAAZ,EAArB;AAEA,UAAMM,UAAU,GAAG,MAAM,KAAKC,4BAAL,CAAkC,KAAKjD,MAAvC,CAAzB;AACA,UAAM2C,oBAAoB,GAAG,MAAM,KAAK3C,MAAL,CAAY4C,SAAZ,CAAsB4C,yBAAyB,CAAChF,OAAhD,CAAnC;AACA,UAAMiF,uBAAuB,GAAGhD,MAAM,CAACM,GAAP,CAAWJ,oBAAX,CAAhC;AACA,UAAMO,aAAa,GAAG,MAAM,KAAKC,2BAAL,EAA5B;AACA,UAAMuC,sBAAsB,GAAG,CAACrC,MAAM,CAACL,UAAD,CAAN,GAAqBK,MAAM,CAACH,aAAD,CAA5B,EAA6CI,OAA7C,CAAqD,CAArD,CAA/B;AAEA,WAAO;AACLC,MAAAA,UAAU,EAAEP,UADP;AAELQ,MAAAA,cAAc,EAAEkC,sBAFX;AAGLhD,MAAAA,WAAW,EAAE/D,iBAAiB,CAAC8D,MAAD,EAAS,KAAKzC,MAAL,CAAYW,OAArB,EAA8B,CAA9B,CAHzB;AAIL8C,MAAAA,iBAAiB,EAAE9E,iBAAiB,CAAC8G,uBAAD,EAA0B,KAAKzF,MAAL,CAAYW,OAAtC,EAA+C,CAA/C;AAJ/B,KAAP;AAMD;;AAE+B,QAA1BgF,0BAA0B,GAAuB;AACrD,UAAM;AAAEC,MAAAA,iBAAF;AAAqBtD,MAAAA;AAArB,QAA2C,KAAK3C,SAAtD;AACA,UAAMkG,aAAa,GAAG,MAAMD,iBAAiB,CAACE,IAAlB,CAAuB,KAAK/F,IAAL,CAAUS,OAAjC,EAA0CjC,MAAM,CAACwH,KAAP,CAAaC,UAAb,CAAwB,GAAxB,CAA1C,CAA5B;AAEA,UAAMvD,MAAM,GAAG,MAAM,KAAK1C,IAAL,CAAU2C,WAAV,EAArB;AACA,UAAMC,oBAAoB,GAAG,MAAM,KAAK5C,IAAL,CAAU6C,SAAV,CAAoBN,iBAAiB,CAAC9B,OAAtC,CAAnC;AACA,UAAMsC,qBAAqB,GAAGL,MAAM,CAACM,GAAP,CAAWJ,oBAAX,CAA9B;AACA,WAAO;AACLY,MAAAA,UAAU,EAAE5E,iBAAiB,CAACkH,aAAD,CADxB;AAELrC,MAAAA,cAAc,EAAE7E,iBAAiB,CAACkH,aAAD,CAF5B;AAGLnD,MAAAA,WAAW,EAAE/D,iBAAiB,CAAC8D,MAAD,EAAS,KAAK1C,IAAL,CAAUY,OAAnB,EAA4B,CAA5B,CAHzB;AAIL8C,MAAAA,iBAAiB,EAAE9E,iBAAiB,CAACmE,qBAAD,EAAwB,KAAK/C,IAAL,CAAUY,OAAlC,EAA2C,CAA3C;AAJ/B,KAAP;AAMD;;AAE2B,QAAtBsF,sBAAsB,GAAuB;AACjD,UAAM;AAAElB,MAAAA;AAAF,QAAe,KAAKpF,SAA1B;AACA,WAAOoF,QAAQ,CAACmB,mBAAT,EAAP;AACD;;AAEwB,QAAnBC,mBAAmB,GAAuB;AAC9C,UAAM;AAAEpB,MAAAA;AAAF,QAAe,KAAKpF,SAA1B;AACA,WAAOoF,QAAQ,CAACqB,mBAAT,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AACmB,QAAXC,WAAW,CAACC,IAAD,EAAiC;AAChD,QAAI,KAAK9G,SAAL,KAAmB+G,SAAvB,EAAkC;AAClC,UAAMC,YAAY,GAAGF,IAAI,CAACE,YAA1B;AACA,UAAMC,YAAY,GAAG,KAAK9G,SAAL,CAAe2G,IAAI,CAAChF,QAApB,CAArB;AACA,UAAMoF,iBAAiB,GAAG,MAAM,KAAKC,6BAAL,CAAmCL,IAAI,CAACM,gBAAxC,EAA0DJ,YAA1D,CAAhC;AACA,UAAMK,WAAW,GAAG,MAAML,YAAY,CAAC5D,SAAb,CAAuB0D,IAAI,CAAC9F,OAA5B,CAA1B;AACA,UAAMsG,GAAG,GAAGzD,MAAM,CAACqD,iBAAD,CAAN,GAA4BrD,MAAM,CAAC1E,iBAAiB,CAACkI,WAAD,EAAcL,YAAY,CAAC7F,OAA3B,CAAlB,CAA9C;AACA,UAAMoG,IAAI,GAAGT,IAAI,CAACU,aAAL,KAAuB,MAAvB,GAAgC,MAAM,KAAK3E,WAAL,EAAtC,GAA2D,MAAM,KAAKkD,YAAL,EAA9E;AACA,UAAM0B,cAAc,GAAG,MAAM,KAAKC,iBAAL,CAC3BZ,IAAI,CAACU,aADsB,EAE3BV,IAAI,CAAChF,QAFsB,EAG3BmF,YAH2B,EAI3BH,IAAI,CAACM,gBAJsB,CAA7B;AAOA,UAAMO,YAAY,GAAGF,cAAc,CAACG,GAAf,CAAmB,EAAnB,EAAuBA,GAAvB,CAA2B,EAA3B,CAArB;AACA,UAAMC,uBAAuB,GAC3BhE,MAAM,CAAC0D,IAAI,CAACvD,cAAN,CAAN,GAA8BH,MAAM,CAAC1E,iBAAiB,CAACwI,YAAY,CAACC,GAAb,CAAiB,EAAjB,EAAqBA,GAArB,CAAyB,GAAzB,CAAD,CAAlB,CADtC;AAEA,UAAME,sBAAsB,GAAGjE,MAAM,CAAC0D,IAAI,CAACvD,cAAN,CAAN,GAA8BH,MAAM,CAAC1E,iBAAiB,CAACwI,YAAY,CAACC,GAAb,CAAiB,EAAjB,CAAD,CAAlB,CAAnE;AACA,UAAMG,uBAAuB,GAC3BlE,MAAM,CAACqD,iBAAD,CAAN,GAA4BrD,MAAM,CAAC1E,iBAAiB,CAACkI,WAAD,EAAcL,YAAY,CAAC7F,OAA3B,CAAlB,CADpC;AAEA,UAAM6G,QAAQ,GAAIF,sBAAsB,GAAGC,uBAA1B,GAAqD,GAAtE;AACA,UAAME,SAAS,GAAIJ,uBAAuB,GAAGE,uBAA3B,GAAsD,GAAxE;AACA,WAAO;AACLC,MAAAA,QAAQ,EAAEA,QAAQ,CAAClE,OAAT,CAAiB,CAAjB,EAAoBoB,QAApB,EADL;AAEL+C,MAAAA,SAAS,EAAEA,SAAS,CAACnE,OAAV,CAAkB,CAAlB,EAAqBoB,QAArB,EAFN;AAGLoC,MAAAA,GAAG,EAAEA,GAAG,CAACxD,OAAJ,CAAY,CAAZ,EAAeoB,QAAf;AAHA,KAAP;AAKD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACyB,QAAjBwC,iBAAiB,CACrBF,aADqB,EAErBU,YAFqB,EAGrBjB,YAHqB,EAIrBG,gBAJqB,EAKrB;AACA,QAAII,aAAa,KAAK,MAAtB,EAA8B;AAC5B,UAAI,CAACU,YAAY,CAACC,QAAb,CAAsB,gBAAtB,CAAL,EAA8C;AAC5C,cAAMC,eAAe,GAAG,MAAMnB,YAAY,CAACoB,aAAb,EAA9B;;AACA,YAAIjB,gBAAgB,KAAK,MAAzB,EAAiC;AAC/B,iBAAOgB,eAAe,CAACR,GAAhB,CAAoB,IAApB,EAA0BU,GAA1B,CAA8B,KAA9B,EAAqCA,GAArC,CAAyC,EAAzC,CAAP;AACD,SAFD,MAEO,IAAIlB,gBAAgB,KAAK,KAAzB,EAAgC;AACrC,iBAAOgB,eAAe,CAACR,GAAhB,CAAoB,IAApB,EAA0BU,GAA1B,CAA8B,KAA9B,EAAqCA,GAArC,CAAyC,EAAzC,CAAP;AACD,SAFM,MAEA,IAAIlB,gBAAgB,KAAK,KAAzB,EAAgC;AACrC,iBAAOgB,eAAe,CAACR,GAAhB,CAAoB,IAApB,EAA0BU,GAA1B,CAA8B,KAA9B,EAAqCA,GAArC,CAAyC,EAAzC,CAAP;AACD,SAFM,MAEA,IAAIlB,gBAAgB,KAAK,OAAzB,EAAkC;AACvC,iBAAOgB,eAAe,CAACR,GAAhB,CAAoB,IAApB,EAA0BU,GAA1B,CAA8B,KAA9B,EAAqCA,GAArC,CAAyC,EAAzC,CAAP;AACD;;AACD,eAAOF,eAAe,CAACE,GAAhB,CAAoB,EAApB,CAAP;AACD;;AACD,YAAMC,aAAa,GAAG,MAAMtB,YAAY,CAACsB,aAAb,EAA5B;AACA,YAAMC,aAAa,GAAG,IAAIC,IAAJ,CAASF,aAAa,CAACG,QAAd,KAA2B,IAApC,CAAtB;AACA,YAAMC,SAAS,GAAG,IAAI,EAAJ,GAAS,EAAT,GAAc,EAAd,GAAmB,IAArC;;AACA,UAAIF,IAAI,CAACG,GAAL,KAAaJ,aAAa,CAACK,OAAd,EAAb,GAAuCF,SAA3C,EAAsD;AACpD,eAAO,MAAM1B,YAAY,CAAC6B,kBAAb,CAAgC,CAAhC,CAAb;AACD;;AACD,aAAO,MAAM7B,YAAY,CAAC6B,kBAAb,CAAgC,CAAhC,CAAb;AACD;;AACD,UAAMV,eAAe,GAAG,MAAMnB,YAAY,CAAC8B,eAAb,EAA9B;;AACA,QAAI3B,gBAAgB,KAAK,aAAzB,EAAwC;AACtC,aAAOgB,eAAe,CAACR,GAAhB,CAAoB,GAApB,EAAyBU,GAAzB,CAA6B,IAA7B,CAAP;AACD,KAFD,MAEO,IAAIlB,gBAAgB,KAAK,eAAzB,EAAyC;AAC9C,aAAOgB,eAAe,CAACR,GAAhB,CAAoB,EAApB,EAAwBU,GAAxB,CAA4B,IAA5B,CAAP;AACD,KAFM,MAEA,IAAIlB,gBAAgB,KAAK,MAAzB,EAAgC;AACrC,aAAOgB,eAAe,CAACR,GAAhB,CAAoB,GAApB,EAAyBU,GAAzB,CAA6B,IAA7B,CAAP;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACqC,QAA7BnB,6BAA6B,CAAC6B,SAAD,EAAoB9G,KAApB,EAAkC;AACnE,QAAI+G,UAAJ;AACA,UAAMC,sBAAsB,GAAG,MAAM,KAAKvF,2BAAL,EAArC;;AACA,QAAIqF,SAAS,KAAK,MAAlB,EAA0B;AACxBC,MAAAA,UAAU,GAAGC,sBAAb;AACD,KAFD,MAEO;AACL,UAAIF,SAAS,KAAK,aAAlB,EAAiC;AAC/BC,QAAAA,UAAU,GAAG,MAAM,KAAKjE,eAAL,CAAqB9C,KAArB,EAA4B,KAAK3B,IAAjC,EAAuC,IAAvC,CAAnB;AACD,OAFD,MAEO,IAAIyI,SAAS,KAAK,eAAlB,EAAmC;AACxCC,QAAAA,UAAU,GAAG,MAAM,KAAKjE,eAAL,CAAqB9C,KAArB,EAA4B,KAAK1B,MAAjC,EAAyC,KAAzC,CAAnB;AACD,OAFM,MAEA,IAAIwI,SAAS,KAAK,OAAlB,EAA2B;AAChCC,QAAAA,UAAU,GAAG,MAAM,KAAKE,2BAAL,CAAiCjH,KAAjC,CAAnB;AACD,OAFM,MAEA;AACL+G,QAAAA,UAAU,GAAG,MAAM,KAAKxF,4BAAL,CAAkCvB,KAAlC,CAAnB;AACA+G,QAAAA,UAAU,GAAG,CAACpF,MAAM,CAACoF,UAAD,CAAN,GAAqBpF,MAAM,CAACqF,sBAAD,CAA5B,EAAsDhE,QAAtD,EAAb;AACD;AACF;;AACD,WAAO+D,UAAP;AACD,GApTsB,CAsTvB;AACA;AACA;AACA;;;AAEqB,QAAfG,eAAe,GAAuB;AAC1C,UAAM;AAAE7D,MAAAA;AAAF,QAAe,KAAKpF,SAA1B;AACA,WAAOoF,QAAQ,CAAC8D,KAAT,EAAP;AACD;;AAEiC,QAA5BC,4BAA4B,GAAuB;AACvD,UAAM;AAAE/D,MAAAA;AAAF,QAAe,KAAKpF,SAA1B;AACA,WAAOoF,QAAQ,CAACG,kBAAT,EAAP;AACD;AAED;AACF;AACA;AACA;;;AACgB,QAAR6D,QAAQ,CAACC,MAAD,EAAwD;AACpE,UAAM;AAAEjE,MAAAA;AAAF,QAAe,KAAKpF,SAA1B;AACA,UAAMsJ,iBAAiB,GAAG,MAAMlE,QAAQ,CAACmE,YAAT,EAAhC;AACA,WAAO,MAAMnE,QAAQ,CAACgE,QAAT,CAAkBvK,gBAAgB,CAACwK,MAAD,CAAlC,EAA4CC,iBAA5C,CAAb;AACD;AAED;AACF;AACA;AACA;;;AACmB,QAAXE,WAAW,CAACH,MAAD,EAA+C;AAC9D,UAAM;AAAEjE,MAAAA;AAAF,QAAe,KAAKpF,SAA1B;AACA,UAAMyJ,YAAY,GAAG,MAAMrE,QAAQ,CAACmE,YAAT,EAA3B;AACA,WAAO,MAAMnE,QAAQ,CAACoE,WAAT,CAAqB3K,gBAAgB,CAACwK,MAAD,CAArC,EAA+CI,YAA/C,CAAb;AACD;;AAEwB,QAAnBC,mBAAmB,GAAoB;AAC3C,QAAIC,UAAU,GAAG,CAAjB;;AACA,SAAK,MAAMC,QAAX,IAAuBjJ,MAAM,CAACmB,MAAP,CAAc1C,eAAd,CAAvB,EAAuD;AACrD,YAAMyK,IAAI,GAAG,KAAK7J,SAAL,CAAe4J,QAAQ,CAACjI,QAAxB,CAAb;AACA,YAAMI,KAAK,GAAG,KAAK9B,cAAL,CAAoB2J,QAAQ,CAAC3C,gBAA7B,CAAd;AACA,YAAM6B,UAAU,GAAG,MAAM,KAAK9B,6BAAL,CAAmC4C,QAAQ,CAAC3C,gBAA5C,EAA8DlF,KAA9D,CAAzB;AACA,YAAM+H,iBAAiB,GAAG,MAAM/H,KAAK,CAACkB,SAAN,CAAgB4G,IAAI,CAAChJ,OAArB,CAAhC;AACA,YAAMkJ,KAAK,GAAGrG,MAAM,CAAC1E,iBAAiB,CAAC8K,iBAAD,EAAoB/H,KAAK,CAACf,OAA1B,CAAlB,CAAN,GAA8D0C,MAAM,CAACoF,UAAD,CAAlF;AACA,YAAMkB,SAAS,GAAGtG,MAAM,CAACuG,KAAP,CAAaF,KAAb,IAAsB,CAAtB,GAA0BA,KAA5C;AACAJ,MAAAA,UAAU,IAAIK,SAAd;AACD;;AAED,UAAME,WAAW,GAAG,CAAC,MAAM,KAAKtE,YAAL,EAAP,EAA4B/B,cAAhD;AACA,UAAMsG,sBAAsB,GAAG,MAAM,KAAK9J,MAAL,CAAY4C,SAAZ,CAAsB,KAAKmH,cAAL,GAAsBvJ,OAA5C,CAArC;AACA,UAAMwJ,UAAU,GAAG3G,MAAM,CAAC1E,iBAAiB,CAACmL,sBAAD,EAAyB,KAAK9J,MAAL,CAAYW,OAArC,CAAlB,CAAN,GAAyE0C,MAAM,CAACwG,WAAD,CAAlG;AAEA,WAAOP,UAAU,GAAGU,UAApB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACuB,QAAfxF,eAAe,CAACb,OAAD,EAAiBjC,KAAjB,EAA+BsC,MAA/B,EAAiE;AACpF,UAAMtB,WAAW,GAAGhE,qBAAqB,CAAC,MAAMiF,OAAO,CAACjB,WAAR,EAAP,EAA8BiB,OAAO,CAAChD,OAAtC,CAAzC,CADoF,CAEpF;;AACA,UAAMsJ,WAAW,GAAGvL,qBAAqB,CAAC,MAAMgD,KAAK,CAACkB,SAAN,CAAgBe,OAAO,CAACnD,OAAxB,CAAP,EAAyCkB,KAAK,CAACf,OAA/C,CAAzC;AACA,UAAMoG,IAAI,GAAG/C,MAAM,KAAK,IAAX,GAAkB,MAAM,KAAK3B,WAAL,EAAxB,GAA6C,MAAM,KAAKkD,YAAL,EAAhE;AACA,UAAM2E,YAAY,GAAGnD,IAAI,CAACvD,cAA1B;AACA,UAAM2G,SAAS,GAAG9G,MAAM,CAAC4G,WAAD,CAAN,GAAsB5G,MAAM,CAACX,WAAD,CAA9C;AACA,UAAM+F,UAAU,GAAG,CAACpF,MAAM,CAAC6G,YAAD,CAAN,GAAuBC,SAAvB,GAAmC,CAApC,GAAuC;AACvDzF,IAAAA,QADgB,EAAnB;AAEA,WAAO+D,UAAP;AACD;;AAEmB,QAAd2B,cAAc,CAClBC,QADkB,EAElBrD,aAFkB,EAGlBsD,MAHkB,EAIlBtJ,OAAO,GAAG,KAAKxB,SAJG,EAKE;AACpB,UAAMgK,IAAI,GAAG,KAAK7J,SAAL,CAAe0K,QAAf,CAAb;;AACA,QAAI;AACF,UAAIrD,aAAa,KAAK,MAAtB,EAA8B;AAC5B,eAAO,MAAMwC,IAAI,CAACe,WAAL,CAAiBD,MAAjB,EAAyBtJ,OAAzB,CAAb;AACD,OAFD,MAEO;AACL,eAAO,MAAMwI,IAAI,CAACgB,YAAL,CAAkBF,MAAlB,EAA0BtJ,OAA1B,CAAb;AACD;AACF,KAND,CAME,OAAOiB,GAAP,EAAY;AACZN,MAAAA,OAAO,CAACO,KAAR,CAAe,mCAAkCsH,IAAI,CAAChJ,OAAQ,KAAIyB,GAAG,CAACE,KAAM,EAA5E;AACA,aAAO9D,SAAS,CAACoM,IAAV,CAAe,CAAf,CAAP;AACD;AACF;;AAEwB,QAAnBC,mBAAmB,CAACL,QAAD,EAAyBC,MAAzB,EAAyCtJ,OAAO,GAAG,KAAKxB,SAAxD,EAAuF;AAC9G,UAAMgK,IAAI,GAAG,KAAK7J,SAAL,CAAe0K,QAAf,CAAb;;AACA,QAAI;AACF,UAAIM,QAAQ,GAAG,MAAMnB,IAAI,CAACmB,QAAL,CAAcL,MAAd,EAAsBtJ,OAAtB,CAArB;AACA,aAAO,MAAM2J,QAAQ,CAAC3B,MAAtB;AACD,KAHD,CAGE,OAAO/G,GAAP,EAAY;AACZN,MAAAA,OAAO,CAACO,KAAR,CAAe,sCAAqCsH,IAAI,CAAChJ,OAAQ,KAAIyB,GAAG,CAACE,KAAM,EAA/E;AACA,aAAO9D,SAAS,CAACoM,IAAV,CAAe,CAAf,CAAP;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;;;AACa,QAALG,KAAK,CAACP,QAAD,EAAyBC,MAAzB,EAAyCtB,MAAzC,EAA0F;AACnG,UAAMQ,IAAI,GAAG,KAAK7J,SAAL,CAAe0K,QAAf,CAAb;AACA,WAAO,MAAMb,IAAI,CAACqB,OAAL,CAAaP,MAAb,EAAqBtB,MAArB,CAAb;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACe,QAAP8B,OAAO,CAACT,QAAD,EAAyBC,MAAzB,EAAyCtB,MAAzC,EAA0F;AACrG,UAAMQ,IAAI,GAAG,KAAK7J,SAAL,CAAe0K,QAAf,CAAb;AACA,WAAO,MAAMb,IAAI,CAACuB,QAAL,CAAcT,MAAd,EAAsBtB,MAAtB,CAAb;AACD;AAED;AACF;AACA;;;AACe,QAAPgC,OAAO,CAACX,QAAD,EAAyBC,MAAzB,EAAuE;AAClF,UAAMd,IAAI,GAAG,KAAK7J,SAAL,CAAe0K,QAAf,CAAb,CADkF,CAElF;;AACA,WAAO,MAAMb,IAAI,CAACuB,QAAL,CAAcT,MAAd,EAAsB,CAAtB,CAAb;AACD;AAED;AACF;AACA;;;AACY,QAAJW,IAAI,CAACZ,QAAD,EAAyBC,MAAzB,EAAyCtJ,OAAO,GAAG,KAAKxB,SAAxD,EAAiG;AACzG,UAAMgK,IAAI,GAAG,KAAK7J,SAAL,CAAe0K,QAAf,CAAb;AACA,QAAIM,QAAQ,GAAG,MAAMnB,IAAI,CAACmB,QAAL,CAAcL,MAAd,EAAsBtJ,OAAtB,CAArB;AACA,WAAO,MAAMwI,IAAI,CAACuB,QAAL,CAAcT,MAAd,EAAsBK,QAAQ,CAAC3B,MAA/B,CAAb;AACD;;AAE8B,QAAzBnH,yBAAyB,GAAoB;AACjD,WAAO,QAAP;AACD;;AAEDkI,EAAAA,cAAc,GAAa;AACzB,QAAI,CAAC,KAAKlK,oBAAV,EAAgC,CAC9B;AACD;;AACD,WAAO,KAAKF,SAAL,CAAeuL,OAAtB;AACD;;AAEDC,EAAAA,kBAAkB,GAAY;AAC5B,WAAO,KAAKtL,oBAAL,KAA8B,QAArC;AACD;;AAEiC,QAA5BoD,4BAA4B,CAACmI,aAAD,EAAwC;AACxE,UAAMC,KAAK,GAAG,MAAM,KAAK5L,QAAL,CAAc4L,KAAlC;AACA,QAAI,CAACA,KAAL,EAAY;AACZ,UAAM;AAAEjK,MAAAA;AAAF,QAAc,KAAKtC,MAAzB;AACA,UAAM;AAAEwM,MAAAA;AAAF,QAAW,KAAKxM,MAAL,CAAYc,cAA7B;AAEA,UAAM2L,IAAI,GAAG,IAAIrN,KAAJ,CAAUkD,OAAV,EAAmBkK,IAAI,CAAC,CAAD,CAAvB,EAA4BA,IAAI,CAAC,CAAD,CAAhC,CAAb;AACA,UAAM5J,KAAK,GAAG,IAAIxD,KAAJ,CAAUkD,OAAV,EAAmBgK,aAAa,CAAC5K,OAAjC,EAA0C4K,aAAa,CAACzK,OAAxD,EAAiEyK,aAAa,CAAC1K,MAA/E,CAAd;;AACA,QAAI;AACF,YAAM8K,WAAW,GAAG,MAAMxN,OAAO,CAACyN,aAAR,CAAsBF,IAAtB,EAA4B7J,KAA5B,EAAmC,KAAKjC,QAAxC,CAA1B;AACA,YAAMiM,WAAW,GAAG,IAAItN,KAAJ,CAAU,CAACoN,WAAD,CAAV,EAAyB9J,KAAzB,CAApB;AAEA,aAAOgK,WAAW,CAACC,QAAZ,CAAqBrI,OAArB,CAA6B,CAA7B,CAAP;AACD,KALD,CAKE,OAAOrB,GAAP,EAAY;AACZN,MAAAA,OAAO,CAACO,KAAR,CAAe,kCAAiCkJ,aAAa,CAAC1K,MAAO,KAAIuB,GAAI,EAA7E;AACD;AACF;;AAEgC,QAA3B0G,2BAA2B,CAACyC,aAAD,EAAwC;AACvE,UAAMC,KAAK,GAAG,MAAM,KAAK5L,QAAL,CAAc4L,KAAlC;AACA,QAAI,CAACA,KAAL,EAAY;AACZ,UAAM;AAAEjK,MAAAA;AAAF,QAAc,KAAKtC,MAAzB;AAEA,UAAM;AAAEwM,MAAAA;AAAF,QAAW,KAAK1L,cAAtB;AAEA,UAAM2L,IAAI,GAAG,IAAIpN,WAAJ,CAAgBiD,OAAhB,EAAyBkK,IAAI,CAAC9K,OAA9B,EAAuC8K,IAAI,CAAC3K,OAA5C,CAAb;AACA,UAAMe,KAAK,GAAG,IAAIvD,WAAJ,CAAgBiD,OAAhB,EAAyBgK,aAAa,CAAC5K,OAAvC,EAAgD4K,aAAa,CAACzK,OAA9D,EAAuEyK,aAAa,CAAC1K,MAArF,CAAd;;AACA,QAAI;AACF,YAAM8K,WAAW,GAAG,MAAMvN,aAAa,CAACwN,aAAd,CAA4BF,IAA5B,EAAkC7J,KAAlC,EAAyC,KAAKjC,QAA9C,CAA1B;AACA,YAAMmM,cAAc,GAAGJ,WAAW,CAACI,cAAnC;AACA,UAAIC,cAAc,GAAG,MAAMP,IAAI,CAAC1I,SAAL,CAAegJ,cAAc,CAACpL,OAA9B,CAA3B;AACA,UAAI4D,SAAS,GAAGf,MAAM,CAAC3E,qBAAqB,CAACmN,cAAD,EAAiBP,IAAI,CAAC3K,OAAtB,CAAtB,CAAtB;AACA,UAAImL,gBAAgB,GAAG,MAAMV,aAAa,CAACxI,SAAd,CAAwBgJ,cAAc,CAACpL,OAAvC,CAA7B;AACA,UAAIuL,WAAW,GAAG1I,MAAM,CAAC3E,qBAAqB,CAACoN,gBAAD,EAAmBV,aAAa,CAACzK,OAAjC,CAAtB,CAAxB;AACA,YAAM+H,sBAAsB,GAAG,MAAM,KAAKvF,2BAAL,EAArC;AACA,UAAI6I,YAAY,GAAI5H,SAAS,GAAG2H,WAAb,GAA4B1I,MAAM,CAACqF,sBAAD,CAArD;AACA,aAAOsD,YAAY,CAACtH,QAAb,EAAP;AACD,KAVD,CAUE,OAAOzC,GAAP,EAAY;AACZN,MAAAA,OAAO,CAACO,KAAR,CAAe,kCAAiCkJ,aAAa,CAAC1K,MAAO,KAAIuB,GAAI,EAA7E;AACD;AACF;;AAEgC,QAA3BkB,2BAA2B,GAAoB;AACnD,UAAMkI,KAAK,GAAG,MAAM,KAAK5L,QAAL,CAAc4L,KAAlC;AACA,QAAI,CAACA,KAAL,EAAY;AACZ,UAAM;AAAEC,MAAAA,IAAF;AAAQW,MAAAA;AAAR,QAAkB,KAAKrM,cAA7B;;AACA,QAAI;AACF,YAAMsM,kBAAkB,GAAG,KAAKtM,cAAL,CAAoB,aAApB,CAA3B;AACA,UAAIuM,aAAa,GAAG,MAAMb,IAAI,CAAC1I,SAAL,CAAesJ,kBAAkB,CAAC1L,OAAlC,CAA1B;AACA,UAAI4L,UAAU,GAAG/I,MAAM,CAAC3E,qBAAqB,CAACyN,aAAD,EAAgBb,IAAI,CAAC3K,OAArB,CAAtB,CAAvB;AACA,UAAI0L,eAAe,GAAG,MAAMJ,KAAK,CAACrJ,SAAN,CAAgBsJ,kBAAkB,CAAC1L,OAAnC,CAA5B;AACA,UAAI8L,YAAY,GAAGjJ,MAAM,CAAC3E,qBAAqB,CAAC2N,eAAD,EAAkBJ,KAAK,CAACtL,OAAxB,CAAtB,CAAzB;AACA,aAAO,CAAC2L,YAAY,GAAGF,UAAhB,EAA4B1H,QAA5B,EAAP;AACD,KAPD,CAOE,OAAOzC,GAAP,EAAY;AACZN,MAAAA,OAAO,CAACO,KAAR,CAAe,wCAAuCD,GAAI,EAA1D;AACD;AACF,GA7gBsB,CA+gBvB;AACA;AACA;AACA;AACA;;;AAEmB,QAAbsK,aAAa,GAAG;AACpB,UAAMrB,OAAO,GAAG,KAAKnB,cAAL,EAAhB;AACA,UAAMyC,mBAAmB,GAAG,MAAMtB,OAAO,CAACsB,mBAAR,EAAlC;AACA,UAAMC,WAAW,GAAG,MAAMvB,OAAO,CAACwB,gBAAR,CAAyBF,mBAAzB,CAA1B;AAEA,UAAMG,mBAAmB,GAAGF,WAAW,CAAC,CAAD,CAAvC;AAEA,UAAM5C,WAAW,GAAG,CAAC,MAAM,KAAKtE,YAAL,EAAP,EAA4B/B,cAAhD;AACA,UAAMoJ,SAAS,GAAG,CAAC,MAAM,KAAKvK,WAAL,EAAP,EAA2BmB,cAA7C;AACA,UAAMqJ,oBAAoB,GAAGF,mBAAmB,GAAG,IAAnD,CAToB,CAWpB;;AACA,UAAMG,qBAAqB,GAAGD,oBAAoB,GAAGxJ,MAAM,CAACuJ,SAAD,CAA7B,GAA2C,CAAzE;AACA,UAAM9C,sBAAsB,GAAG,MAAM,KAAK9J,MAAL,CAAY4C,SAAZ,CAAsBsI,OAAO,CAAC1K,OAA9B,CAArC;AACA,UAAMwJ,UAAU,GAAG3G,MAAM,CAAC1E,iBAAiB,CAACmL,sBAAD,EAAyB,KAAK9J,MAAL,CAAYW,OAArC,CAAlB,CAAN,GAAyE0C,MAAM,CAACwG,WAAD,CAAlG;AACA,UAAMkD,OAAO,GAAKD,qBAAqB,GAAG,GAAzB,GAAgC9C,UAAjC,GAA+C,GAA/D;AACA,WAAO+C,OAAP;AACD;AAED;AACF;AACA;AACA;;;AACqC,QAA7BC,6BAA6B,GAAqB;AACtD,UAAM9B,OAAO,GAAG,KAAKnB,cAAL,EAAhB;AACA,WAAO,MAAMmB,OAAO,CAAC+B,cAAR,CAAuB,KAAKzN,SAA5B,CAAb;AACD;AAED;AACF;AACA;AACA;;;AACiC,QAAzB0N,yBAAyB,GAAqB;AAClD,UAAMhC,OAAO,GAAG,KAAKnB,cAAL,EAAhB;AACA,UAAMoD,WAAW,GAAG,MAAMjC,OAAO,CAACiC,WAAR,CAAoB,KAAK3N,SAAzB,CAA1B;AACA,UAAM4N,YAAY,GAAG,MAAM,KAAKC,wBAAL,EAA3B;AACA,UAAMC,SAAS,GAAGjK,MAAM,CAAC1E,iBAAiB,CAACyO,YAAD,EAAe,KAAKpN,MAAL,CAAYW,OAA3B,CAAlB,CAAN,KAAiE,CAAnF;AACA,UAAM4M,MAAM,GAAGD,SAAS,GAAG,IAAH,GAAUH,WAAlC;AACA,WAAOI,MAAP;AACD;;AAEoC,QAA/BC,+BAA+B,GAAuB;AAC1D;AACA;AACA,WAAOnP,SAAS,CAACoM,IAAV,CAAe,CAAf,CAAP;AACD;;AAE4B,QAAvBgD,uBAAuB,GAAuB;AAClD,UAAMvC,OAAO,GAAG,KAAKnB,cAAL,EAAhB;AACA,WAAO,MAAMmB,OAAO,CAACxI,WAAR,EAAb;AACD;;AAEwB,QAAnBgL,mBAAmB,CAAC1E,MAAD,EAA+C;AACtE,QAAI,KAAKmC,kBAAL,EAAJ,EAA+B;AAC7B,YAAM,IAAIwC,KAAJ,CAAU,yEAAV,CAAN;AACD;;AACD,UAAMzC,OAAO,GAAG,KAAKnB,cAAL,EAAhB;AACA,WAAO,MAAMmB,OAAO,CAACN,KAAR,CAAcpM,gBAAgB,CAACwK,MAAD,CAA9B,CAAb;AACD;;AAE6B,QAAxBqE,wBAAwB,GAAuB;AACnD,UAAMnC,OAAO,GAAG,KAAKnB,cAAL,EAAhB;;AACA,QAAI,KAAKlK,oBAAL,KAA8B,IAAlC,EAAwC;AACtC,aAAO,MAAMqL,OAAO,CAAC0C,UAAR,CAAmB,KAAKpO,SAAxB,CAAb;AACD;;AACD,WAAO,MAAM0L,OAAO,CAACtI,SAAR,CAAkB,KAAKpD,SAAvB,CAAb;AACD;;AAEyB,QAApBqO,oBAAoB,GAAuB;AAC/C,UAAM3C,OAAO,GAAG,KAAKnB,cAAL,EAAhB;;AACA,QAAI,KAAKlK,oBAAL,KAA8B,IAAlC,EAAwC;AACtC,aAAO,MAAMqL,OAAO,CAAC4C,iBAAR,CAA0B,KAAKtO,SAA/B,CAAb;AACD;;AACD,WAAO,MAAM0L,OAAO,CAAC6C,MAAR,CAAe,KAAKvO,SAApB,CAAb;AACD;;AAE6B,QAAxBwO,wBAAwB,CAAChF,MAAD,EAA+C;AAC3E,UAAMkC,OAAO,GAAG,KAAKnB,cAAL,EAAhB;AACA,WAAO,MAAMmB,OAAO,CAACH,QAAR,CAAiBvM,gBAAgB,CAACwK,MAAD,CAAjC,CAAb;AACD;;AAE2B,QAAtBiF,sBAAsB,GAAiC;AAC3D,UAAM/C,OAAO,GAAG,KAAKnB,cAAL,EAAhB;;AACA,QAAI,KAAKlK,oBAAL,KAA8B,IAAlC,EAAwC;AACtC,aAAO,MAAMqL,OAAO,CAACgD,cAAR,EAAb;AACD;;AACD,WAAO,MAAMhD,OAAO,CAACiD,WAAR,EAAb;AACD;;AAEoB,QAAfC,eAAe,GAAiC;AACpD,UAAMlD,OAAO,GAAG,KAAKnB,cAAL,EAAhB;AACA,WAAO,MAAMmB,OAAO,CAACD,IAAR,EAAb;AACD;;AAEwB,QAAnBoD,mBAAmB,GAAiC;AACxD,UAAM;AAAEtJ,MAAAA;AAAF,QAAe,KAAKpF,SAA1B;AACA,WAAO,MAAMoF,QAAQ,CAACsJ,mBAAT,EAAb;AACD;;AAEkC,QAA7BC,6BAA6B,GAA4B;AAC7D,UAAM;AAAEvJ,MAAAA;AAAF,QAAe,KAAKpF,SAA1B;AACA,UAAM4O,kBAA6B,GAAG,MAAMxJ,QAAQ,CAACyJ,cAAT,EAA5C;AACA,UAAMC,cAAc,GAAG,IAAIxG,IAAJ,CAASsG,kBAAkB,CAACnH,GAAnB,CAAuB,IAAvB,EAA6Bc,QAA7B,EAAT,CAAvB;AACA,UAAMwG,cAAc,GAAG,IAAIzG,IAAJ,CAASA,IAAI,CAACG,GAAL,EAAT,CAAvB;AAEA,WAAO;AAAEqC,MAAAA,IAAI,EAAEiE,cAAR;AAAwBC,MAAAA,EAAE,EAAEF;AAA5B,KAAP;AACD;AACD;AACF;AACA;AACA;AACA;AACA;;;AAC8B,QAAtBG,sBAAsB,GAA4B;AACtD,UAAM;AAAE1D,MAAAA,OAAF;AAAWnG,MAAAA;AAAX,QAAwB,KAAKpF,SAAnC;AACA,UAAM4O,kBAAkB,GAAG,MAAMrD,OAAO,CAACsD,cAAR,EAAjC,CAFsD,CAEK;;AAC3D,UAAMK,YAAY,GAAG,MAAM3D,OAAO,CAACrC,KAAR,EAA3B;AACA,UAAMiG,KAAK,GAAG,MAAM5D,OAAO,CAAC6D,MAAR,CAAe,KAAKvP,SAApB,CAApB;AACA,UAAMwP,cAAc,GAAGF,KAAK,CAACG,eAA7B;AACA,UAAMC,MAAM,GAAG,MAAMnK,QAAQ,CAACoK,MAAT,EAArB;AACA,UAAMC,aAAa,GAAGF,MAAM,GAAG,EAAT,GAAc,EAApC,CAPsD,CAOd;;AACxC,UAAMG,kBAAkB,GAAG,MAAMnE,OAAO,CAACmE,kBAAR,EAAjC;AACA,UAAMC,yBAAyB,GAAGjM,MAAM,CAAC2L,cAAD,CAAN,GAAyB3L,MAAM,CAACgM,kBAAD,CAAjE;AAEA,UAAME,QAAQ,GAAG,IAAItH,IAAJ,CAASA,IAAI,CAACG,GAAL,EAAT,CAAjB;;AACA,QAAIkH,yBAAyB,GAAGT,YAA5B,IAA4C,CAAhD,EAAmD;AACjD,aAAO;AAAEpE,QAAAA,IAAI,EAAE8E,QAAR;AAAkBZ,QAAAA,EAAE,EAAEY;AAAtB,OAAP;AACD,KAFD,MAEO,IAAID,yBAAyB,GAAGT,YAA5B,KAA6C,CAAjD,EAAoD;AACzD,YAAMW,MAAM,GAAG,IAAIvH,IAAJ,CAASsG,kBAAkB,GAAG,IAA9B,CAAf;AACA,aAAO;AAAE9D,QAAAA,IAAI,EAAE8E,QAAR;AAAkBZ,QAAAA,EAAE,EAAEa;AAAtB,OAAP;AACD,KAHM,MAGA;AACL,YAAMA,MAAM,GAAG,IAAIvH,IAAJ,CAASsG,kBAAkB,GAAG,IAA9B,CAAf;AACA,YAAMkB,KAAK,GAAGH,yBAAyB,GAAGT,YAA5B,GAA2C,CAAzD;AACA,YAAMa,OAAO,GAAG1Q,MAAM,CAACwQ,MAAD,CAAN,CACbG,GADa,CACTF,KAAK,GAAGL,aADC,EACc,OADd,EAEbI,MAFa,EAAhB;AAGA,aAAO;AAAE/E,QAAAA,IAAI,EAAE8E,QAAR;AAAkBZ,QAAAA,EAAE,EAAEe;AAAtB,OAAP;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;;;AAC0B,QAAlBE,kBAAkB,GAA4B;AAClD,UAAM;AAAE1E,MAAAA,OAAF;AAAWnG,MAAAA;AAAX,QAAwB,KAAKpF,SAAnC;AACA,UAAM4O,kBAAkB,GAAG,MAAMrD,OAAO,CAACsD,cAAR,EAAjC;AACA,UAAMK,YAAY,GAAG,MAAM3D,OAAO,CAACrC,KAAR,EAA3B;AACA,UAAMiG,KAAK,GAAG,MAAM5D,OAAO,CAAC6D,MAAR,CAAe,KAAKvP,SAApB,CAApB;AACA,UAAMwP,cAAc,GAAGF,KAAK,CAACG,eAA7B;AACA,UAAMC,MAAM,GAAG,MAAMnK,QAAQ,CAACoK,MAAT,EAArB;AACA,UAAMU,aAAa,GAAGX,MAAM,GAAG,EAAT,GAAc,EAApC;AACA,UAAMY,oBAAoB,GAAG,MAAM5E,OAAO,CAAC4E,oBAAR,EAAnC;AACA,UAAMP,QAAQ,GAAG,IAAItH,IAAJ,CAASA,IAAI,CAACG,GAAL,EAAT,CAAjB;AACA,UAAMkH,yBAAyB,GAAGjM,MAAM,CAAC2L,cAAD,CAAN,GAAyB3L,MAAM,CAACyM,oBAAD,CAAjE;AACA,UAAM1C,YAAY,GAAG,MAAM,KAAKC,wBAAL,EAA3B;;AACA,QAAIwB,YAAY,IAAIS,yBAAhB,IAA6CjM,MAAM,CAAC+J,YAAD,CAAN,KAAyB,CAA1E,EAA6E;AAC3E,aAAO;AAAE3C,QAAAA,IAAI,EAAE8E,QAAR;AAAkBZ,QAAAA,EAAE,EAAEY;AAAtB,OAAP;AACD,KAFD,MAEO,IAAID,yBAAyB,GAAGT,YAA5B,KAA6C,CAAjD,EAAoD;AACzD,YAAMW,MAAM,GAAG,IAAIvH,IAAJ,CAASsG,kBAAkB,GAAG,IAA9B,CAAf;AACA,aAAO;AAAE9D,QAAAA,IAAI,EAAE8E,QAAR;AAAkBZ,QAAAA,EAAE,EAAEa;AAAtB,OAAP;AACD,KAHM,MAGA;AACL,YAAMA,MAAM,GAAG,IAAIvH,IAAJ,CAASsG,kBAAkB,GAAG,IAA9B,CAAf;AACA,YAAMkB,KAAK,GAAGH,yBAAyB,GAAGjM,MAAM,CAACwL,YAAD,CAAlC,GAAmD,CAAjE;AACA,YAAMa,OAAO,GAAG1Q,MAAM,CAACwQ,MAAD,CAAN,CACbG,GADa,CACTF,KAAK,GAAGI,aADC,EACc,OADd,EAEbL,MAFa,EAAhB;AAGA,aAAO;AAAE/E,QAAAA,IAAI,EAAE8E,QAAR;AAAkBZ,QAAAA,EAAE,EAAEe;AAAtB,OAAP;AACD;AACF;;AAEyB,QAApBK,oBAAoB,CAACC,SAAD,EAAsC;AAC9D,UAAM;AAAEC,MAAAA;AAAF,QAAeC,MAArB;;AACA,QAAID,QAAQ,IAAIA,QAAQ,CAACE,cAAT,KAA4BrR,MAAM,CAACsC,OAAP,CAAesD,QAAf,EAA5C,EAAuE;AACrE,UAAI0L,KAAJ;AACA,UAAIC,QAAJ;;AACA,UAAIL,SAAS,KAAK,MAAlB,EAA0B;AACxBI,QAAAA,KAAK,GAAG,KAAKrQ,IAAb;AACAsQ,QAAAA,QAAQ,GAAG,kDAAX;AACD,OAHD,MAGO,IAAIL,SAAS,KAAK,QAAlB,EAA4B;AACjCI,QAAAA,KAAK,GAAG,KAAKpQ,MAAb;AACAqQ,QAAAA,QAAQ,GAAG,oDAAX;AACD,OAHM,MAGA,IAAIL,SAAS,KAAK,OAAlB,EAA2B;AAChCI,QAAAA,KAAK,GAAG,KAAKnQ,KAAb;AACAoQ,QAAAA,QAAQ,GAAG,mDAAX;AACD;;AACD,YAAMJ,QAAQ,CAACK,OAAT,CAAiB;AACrBC,QAAAA,MAAM,EAAE,mBADa;AAErBC,QAAAA,MAAM,EAAE;AACNC,UAAAA,IAAI,EAAE,OADA;AAENC,UAAAA,OAAO,EAAE;AACPlQ,YAAAA,OAAO,EAAE4P,KAAK,CAAC5P,OADR;AAEPE,YAAAA,MAAM,EAAE0P,KAAK,CAAC1P,MAFP;AAGPiQ,YAAAA,QAAQ,EAAE,EAHH;AAIPC,YAAAA,KAAK,EAAEP;AAJA;AAFH;AAFa,OAAjB,CAAN;AAYD;;AACD,WAAO,IAAP;AACD;;AAEqB,QAAhBQ,gBAAgB,CAACzM,SAAD,EAAoB0M,UAApB,EAAyE;AAC7F,UAAM;AAAEC,MAAAA;AAAF,QAAgB,KAAKpR,SAA3B;AACA,QAAIqR,SAAS,GAAG;AACdtH,MAAAA,KAAK,EAAEzK,UAAU,CAACmF,SAAD,EAAY,EAAZ;AADH,KAAhB;AAGA,WAAO,MAAM2M,SAAS,CAACE,sBAAV,CAAiCH,UAAjC,EAA6CA,UAAU,CAAC1J,GAAX,CAAe,GAAf,EAAoBU,GAApB,CAAwB,IAAxB,CAA7C,EAA4E7I,UAAU,CAACmF,SAAD,EAAY,EAAZ,CAAV,CAA0BgD,GAA1B,CAA8B,GAA9B,EAAmCU,GAAnC,CAAuC,IAAvC,CAA5E,EAA0HkJ,SAA1H,CAAb;AACD;;AAEoB,QAAfE,eAAe,CAAChN,WAAD,EAAsBsE,SAAtB,EAA0D;AAC7E,UAAM;AAAE2I,MAAAA;AAAF,QAAmB,KAAKxR,SAA9B;AACA,UAAM;AAAEyR,MAAAA,SAAF;AAAaC,MAAAA;AAAb,QAA2B,MAAM,KAAKvR,WAAL,CAAiBwR,WAAjB,EAAvC;AACA,QAAIC,KAAJ;;AACA,QAAI/I,SAAS,KAAK,MAAlB,EAA0B;AACxB+I,MAAAA,KAAK,GAAG,MAAMJ,YAAY,CAACI,KAAb,CAAmBtS,UAAU,CAACiF,WAAD,CAA7B,EAA4CmN,SAA5C,EAAuDD,SAAvD,CAAd;AACD,KAFD,MAEO;AACLG,MAAAA,KAAK,GAAG,MAAMJ,YAAY,CAACI,KAAb,CAAmBtS,UAAU,CAACiF,WAAD,CAA7B,EAA4CkN,SAA5C,EAAuDC,SAAvD,CAAd;AACD;;AACD,WAAO,CAACE,KAAK,GAAG,IAAT,EAAe7M,QAAf,EAAP;AACD;AAED;AACF;AACA;;;AACkC,QAA1B8M,0BAA0B,GAAiB;AAC/C,UAAM;AAAEzM,MAAAA;AAAF,QAAe,KAAKpF,SAA1B;AAEA,UAAM8R,uBAAuB,GAAG1M,QAAQ,CAAC2M,OAAT,CAAiBC,aAAjB,EAAhC;AACA,UAAMC,uBAAuB,GAAG7M,QAAQ,CAAC2M,OAAT,CAAiBG,aAAjB,EAAhC;AACA,UAAMC,2BAA2B,GAAG/M,QAAQ,CAAC2M,OAAT,CAAiBK,aAAjB,EAApC;AACA,UAAMC,iBAAiB,GAAGjN,QAAQ,CAAC2M,OAAT,CAAiBO,WAAjB,EAA1B;AACA,UAAMC,iBAAiB,GAAGnN,QAAQ,CAAC2M,OAAT,CAAiBS,aAAjB,EAA1B;AAEA,QAAIC,iBAAwB,GAAG,EAA/B;AACA,QAAIC,iBAAiB,GAAG,MAAMtN,QAAQ,CAACuN,WAAT,CAAqBR,2BAArB,CAA9B;AACA,QAAIS,MAAa,GAAG,EAApB;AACAF,IAAAA,iBAAiB,CAACG,OAAlB,CAA0B,SAASC,QAAT,CAAkB/I,KAAlB,EAAyBgJ,KAAzB,EAAgC;AACxDH,MAAAA,MAAM,CAACI,IAAP,CAAY;AAAE9J,QAAAA,KAAK,EAAE6J,KAAK,GAAG;AAAjB,OAAZ;AACAH,MAAAA,MAAM,CAACG,KAAD,CAAN,CAAcE,WAAd,GAA4BjU,iBAAiB,CAAC+K,KAAK,CAACmJ,IAAN,CAAW,CAAX,CAAD,CAA7C;;AACA,UAAIH,KAAK,KAAK,CAAd,EAAiB;AACfN,QAAAA,iBAAiB,CAACO,IAAlB,CAAuB;AACrBD,UAAAA,KAAK,EAAEA,KADc;AAErBI,UAAAA,UAAU,EAAEpJ,KAAK,CAACqJ,WAFG;AAGrBC,UAAAA,UAAU,EAAE,CAHS;AAIrBC,UAAAA,aAAa,EAAE;AAJM,SAAvB;AAMD;;AACD,UAAIP,KAAK,GAAG,CAAZ,EAAe;AACbN,QAAAA,iBAAiB,CAACO,IAAlB,CAAuB;AACrBD,UAAAA,KAAK,EAAEA,KADc;AAErBI,UAAAA,UAAU,EAAEpJ,KAAK,CAACqJ,WAFG;AAGrBC,UAAAA,UAAU,EAAE,CAHS;AAIrBC,UAAAA,aAAa,EAAE;AAJM,SAAvB;AAMAb,QAAAA,iBAAiB,CAACM,KAAK,GAAG,CAAT,CAAjB,CAA6BQ,QAA7B,GAAwCxJ,KAAK,CAACqJ,WAA9C;AACD;AACF,KApBD;AAsBAX,IAAAA,iBAAiB,CAACI,OAAlB,CAA0B,OAAO9I,KAAP,EAAcgJ,KAAd,KAAwB;AAChDH,MAAAA,MAAM,CAACG,KAAD,CAAN,CAAcS,WAAd,GAA4B,MAAM,KAAKC,2BAAL,CAChCpB,iBADgC,EAEhCtI,KAAK,CAACoJ,UAF0B,EAGhCpJ,KAAK,CAACwJ,QAH0B,CAAlC;AAKAX,MAAAA,MAAM,CAACG,KAAD,CAAN,CAAcW,aAAd,GAA8B,MAAM,KAAKD,2BAAL,CAClClB,iBADkC,EAElCxI,KAAK,CAACoJ,UAF4B,EAGlCpJ,KAAK,CAACwJ,QAH4B,CAApC;AAKD,KAXD;AAYA,QAAII,aAAa,GAAG,MAAMvO,QAAQ,CAACuN,WAAT,CAAqBV,uBAArB,CAA1B;AACA0B,IAAAA,aAAa,CAACd,OAAd,CAAsB,SAASC,QAAT,CAAkB/I,KAAlB,EAAyBgJ,KAAzB,EAAgC;AACpDH,MAAAA,MAAM,CAACG,KAAD,CAAN,CAAca,OAAd,GAAwB5U,iBAAiB,CAAC+K,KAAK,CAACmJ,IAAN,CAAW,CAAX,CAAD,CAAzC;AACD,KAFD;AAGA,QAAIW,aAAa,GAAG,MAAMzO,QAAQ,CAACuN,WAAT,CAAqBb,uBAArB,CAA1B;AACA+B,IAAAA,aAAa,CAAChB,OAAd,CAAsB,SAASC,QAAT,CAAkB/I,KAAlB,EAAyBgJ,KAAzB,EAAgC;AACpDH,MAAAA,MAAM,CAACG,KAAD,CAAN,CAAce,OAAd,GAAwB9U,iBAAiB,CAAC+K,KAAK,CAACmJ,IAAN,CAAW,CAAX,CAAD,CAAzC;AACD,KAFD;AAGA,WAAON,MAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACmC,QAA3Ba,2BAA2B,CAACM,MAAD,EAAsBjJ,IAAtB,EAAoCkE,EAApC,EAAiE;AAChG,UAAM;AAAE5J,MAAAA;AAAF,QAAe,KAAKpF,SAA1B;AACA,UAAMgU,WAAW,GAAG,MAAM5O,QAAQ,CAACuN,WAAT,CAAqBoB,MAArB,EAA6BjJ,IAA7B,EAAmCkE,EAAnC,CAA1B;AACA,WAAOgF,WAAW,CAACC,MAAnB;AACD;;AAEkB,QAAbC,aAAa,CAACrL,SAAD,EAAoBsL,MAApB,EAAoC9K,MAApC,EAAuE;AACxF,UAAM;AAAE+K,MAAAA;AAAF,QAAa,KAAKpU,SAAxB;AACA,UAAMgE,OAAO,GAAG,KAAK/D,cAAL,CAAoBkU,MAApB,CAAhB;AACA,QAAIE,QAAJ;;AACA,QAAIxL,SAAS,KAAKtJ,UAAlB,EAA8B;AAC5B8U,MAAAA,QAAQ,GAAG,MAAMD,MAAM,CAACF,aAAP,CAAqBlQ,OAAO,CAACnD,OAA7B,EAAsCrB,kBAAtC,EAA0DF,UAAU,CAAC+J,MAAD,EAAS,EAAT,CAApE,CAAjB;AACD,KAFD,MAEO;AACL,YAAMtH,KAAK,GAAG8G,SAAS,KAAKpJ,WAAd,GAA4B,KAAKW,IAAjC,GAAwC,KAAKC,MAA3D;AACAgU,MAAAA,QAAQ,GAAG,MAAMD,MAAM,CAACE,kBAAP,CACfvS,KAAK,CAAClB,OADS,EAEfmD,OAAO,CAACnD,OAFO,EAGfrB,kBAHe,EAIfF,UAAU,CAAC+J,MAAD,EAAS,EAAT,CAJK,CAAjB;AAMD;;AACD,WAAO,CAACgL,QAAQ,CAAC,CAAD,CAAR,GAAc,IAAf,EAAqBA,QAAQ,CAAC,CAAD,CAAR,GAAc,IAAnC,CAAP;AACD;;AACU,QAALE,KAAK,CAAC1L,SAAD,EAAoBsL,MAApB,EAAoC9K,MAApC,EAAkF;AAC3F,UAAM;AAAE+K,MAAAA;AAAF,QAAa,KAAKpU,SAAxB;AACA,UAAMgE,OAAO,GAAG,KAAK/D,cAAL,CAAoBkU,MAApB,CAAhB;;AACA,QAAItL,SAAS,KAAKtJ,UAAlB,EAA8B;AAC5B,UAAI8R,SAAS,GAAG;AACdtH,QAAAA,KAAK,EAAEzK,UAAU,CAAC+J,MAAD,EAAS,EAAT;AADH,OAAhB;AAGA,aAAO,MAAM+K,MAAM,CAACG,KAAP,CAAavQ,OAAO,CAACnD,OAArB,EAA8BrB,kBAA9B,EAAkD,KAAKK,SAAvD,EAAkEwR,SAAlE,CAAb;AACD,KALD,MAKO;AACL,YAAMtP,KAAK,GAAG8G,SAAS,KAAKpJ,WAAd,GAA4B,KAAKW,IAAjC,GAAwC,KAAKC,MAA3D;AACA,aAAO,MAAM+T,MAAM,CAACI,UAAP,CACXzS,KAAK,CAAClB,OADK,EAEXvB,UAAU,CAAC+J,MAAD,EAAS,EAAT,CAFC,EAGXrF,OAAO,CAACnD,OAHG,EAIXrB,kBAJW,EAKX,KAAKK,SALM,CAAb;AAOD;AACF;;AACsB,QAAjB4U,iBAAiB,CAACC,WAAD,EAAuD;AAC5E,UAAM;AAAEC,MAAAA;AAAF,QAAoB,KAAK3U,SAA/B;AACA,WAAO,MAAM2U,aAAa,CAACF,iBAAd,CAAgCC,WAAhC,CAAb;AACD;;AAC2B,QAAtBE,sBAAsB,CAACF,WAAD,EAAuC;AACjE,UAAM;AAAEC,MAAAA;AAAF,QAAoB,KAAK3U,SAA/B;;AACA,QAAI;AACF,YAAM6U,UAAU,GAAG,MAAMF,aAAa,CAACC,sBAAd,CAAqCtV,UAAU,CAACoV,WAAD,EAAc,EAAd,CAA/C,CAAzB;AACA,aAAO1V,iBAAiB,CAAC6V,UAAD,EAAa,EAAb,EAAiB,CAAjB,CAAxB;AACD,KAHD,CAGE,OAAOvS,GAAP,EAAY;AACZN,MAAAA,OAAO,CAACO,KAAR,CAAe,2CAA0CD,GAAI,EAA7D;AACD;AACF;;AAEyB,QAApBwS,oBAAoB,CAACjU,OAAD,EAA8C;AACtE,UAAM;AAAE8T,MAAAA;AAAF,QAAoB,KAAK3U,SAA/B;AACA,UAAM+U,eAAe,GAAG,MAAMJ,aAAa,CAACK,gBAAd,EAA9B;AACA,UAAMC,cAAc,GAAG,MAAMN,aAAa,CAACO,eAAd,CAA8BrU,OAA9B,CAA7B,CAHsE,CAItE;AACA;;AACA,UAAMsU,mBAAmB,GAAG,MAAMR,aAAa,CAACS,sBAAd,EAAlC;AACA,UAAMC,aAAa,GAAGrW,iBAAiB,CAAC+V,eAAD,EAAkB,EAAlB,EAAsB,CAAtB,CAAvC;AACA,UAAMO,YAAY,GAAGtW,iBAAiB,CAACiW,cAAD,EAAiB,EAAjB,EAAqB,CAArB,CAAtC;AACA,WAAO;AACLI,MAAAA,aAAa,EAAEA,aAAa,CAACtQ,QAAd,EADV;AAELuQ,MAAAA,YAAY,EAAEA,YAAY,CAACvQ,QAAb,EAFT;AAGL;AACA;AACAwQ,MAAAA,iBAAiB,EAAEJ,mBAAmB,CAACpQ,QAApB;AALd,KAAP;AAOD;;AAh4BsB","sourcesContent":["// import { Fetcher, Route, Token } from '@uniswap/sdk';\nimport { Fetcher as FetcherSpirit, Token as TokenSpirit } from '@spiritswap/sdk';\nimport { Fetcher, Route, Token } from '@spookyswap/sdk';\nimport { Configuration } from './config';\nimport { ContractName, TokenStat, AllocationTime, LPStat, Bank, PoolStats, TShareSwapperStat } from './types';\nimport { BigNumber, Contract, ethers, EventFilter } from 'ethers';\nimport { decimalToBalance } from './ether-utils';\nimport { TransactionResponse } from '@ethersproject/providers';\nimport ERC20 from './ERC20';\nimport { getFullDisplayBalance, getDisplayBalance } from '../utils/formatBalance';\nimport { getDefaultProvider } from '../utils/provider';\nimport IUniswapV2PairABI from './IUniswapV2Pair.abi.json';\nimport config, { bankDefinitions } from '../config';\nimport moment from 'moment';\nimport { parseUnits } from 'ethers/lib/utils';\nimport { FTM_TICKER, SPOOKY_ROUTER_ADDR, TOMB_TICKER } from '../utils/constants';\n/**\n * An API module of Apex Finance contracts.\n * All contract-interacting domain logic should be defined in here.\n */\nexport class TombFinance {\n  myAccount: string;\n  provider: ethers.providers.Web3Provider;\n  signer?: ethers.Signer;\n  config: Configuration;\n  contracts: { [name: string]: Contract };\n  externalTokens: { [name: string]: ERC20 };\n  masonryVersionOfUser?: string;\n\n  TOMBWFTM_LP: Contract;\n  APEX: ERC20;\n  ASHARE: ERC20;\n  ABOND: ERC20;\n  FTM: ERC20;\n\n  constructor(cfg: Configuration) {\n    const { deployments, externalTokens } = cfg;\n    const provider = getDefaultProvider();\n\n    // loads contracts from deployments\n    this.contracts = {};\n    for (const [name, deployment] of Object.entries(deployments)) {\n      this.contracts[name] = new Contract(deployment.address, deployment.abi, provider);\n    }\n    this.externalTokens = {};\n    for (const [symbol, [address, decimal]] of Object.entries(externalTokens)) {\n      this.externalTokens[symbol] = new ERC20(address, provider, symbol, decimal);\n    }\n    this.APEX = new ERC20(deployments.tomb.address, provider, 'APEX');\n    this.ASHARE = new ERC20(deployments.tShare.address, provider, 'ASHARE');\n    this.ABOND = new ERC20(deployments.tBond.address, provider, 'ABOND');\n    this.FTM = this.externalTokens['WFTM'];\n\n    // Uniswap V2 Pair\n    this.TOMBWFTM_LP = new Contract(externalTokens['APEX-FTM-LP'][0], IUniswapV2PairABI, provider);\n\n    this.config = cfg;\n    this.provider = provider;\n  }\n\n  /**\n   * @param provider From an unlocked wallet. (e.g. Metamask)\n   * @param account An address of unlocked wallet account.\n   */\n  unlockWallet(provider: any, account: string) {\n    const newProvider = new ethers.providers.Web3Provider(provider, this.config.chainId);\n    this.signer = newProvider.getSigner(0);\n    this.myAccount = account;\n    for (const [name, contract] of Object.entries(this.contracts)) {\n      this.contracts[name] = contract.connect(this.signer);\n    }\n    const tokens = [this.APEX, this.ASHARE, this.ABOND, ...Object.values(this.externalTokens)];\n    for (const token of tokens) {\n      token.connect(this.signer);\n    }\n    this.TOMBWFTM_LP = this.TOMBWFTM_LP.connect(this.signer);\n    console.log(`ðŸ”“ Wallet is unlocked. Welcome, ${account}!`);\n    this.fetchMasonryVersionOfUser()\n      .then((version) => (this.masonryVersionOfUser = version))\n      .catch((err) => {\n        console.error(`Failed to fetch masonry version: ${err.stack}`);\n        this.masonryVersionOfUser = 'latest';\n      });\n  }\n\n  get isUnlocked(): boolean {\n    return !!this.myAccount;\n  }\n\n  //===================================================================\n  //===================== GET ASSET STATS =============================\n  //===================FROM SPOOKY TO DISPLAY =========================\n  //=========================IN HOME PAGE==============================\n  //===================================================================\n\n  async getTombStat(): Promise<TokenStat> {\n    const { ApexFtmRewardPool, ApexFtmLPApexRewardPool, ApexFtmLPApexRewardPoolOld } = this.contracts;\n    const supply = await this.APEX.totalSupply();\n    const tombRewardPoolSupply = await this.APEX.balanceOf(ApexFtmRewardPool.address);\n    const tombRewardPoolSupply2 = await this.APEX.balanceOf(ApexFtmLPApexRewardPool.address);\n    // const tombRewardPoolSupplyOld = await this.APEX.balanceOf(ApexFtmLPApexRewardPoolOld.address);\n    const tombCirculatingSupply = supply\n      .sub(tombRewardPoolSupply)\n      .sub(tombRewardPoolSupply2);\n      // .sub(tombRewardPoolSupplyOld);\n    const priceInFTM = await this.getTokenPriceFromPancakeswap(this.APEX);\n    const priceOfOneFTM = await this.getWFTMPriceFromPancakeswap();\n    const priceOfTombInDollars = (Number(priceInFTM) * Number(priceOfOneFTM)).toFixed(2);\n\n    return {\n      tokenInFtm: priceInFTM,\n      priceInDollars: priceOfTombInDollars,\n      totalSupply: getDisplayBalance(supply, this.APEX.decimal, 0),\n      circulatingSupply: getDisplayBalance(tombCirculatingSupply, this.APEX.decimal, 0),\n    };\n  }\n\n  /**\n   * Calculates various stats for the requested LP\n   * @param name of the LP token to load stats for\n   * @returns\n   */\n  async getLPStat(name: string): Promise<LPStat> {\n    const lpToken = this.externalTokens[name];\n    const lpTokenSupplyBN = await lpToken.totalSupply();\n    const lpTokenSupply = getDisplayBalance(lpTokenSupplyBN, 18);\n    const token0 = name.startsWith('APEX') ? this.APEX : this.ASHARE;\n    const isTomb = name.startsWith('APEX');\n    const tokenAmountBN = await token0.balanceOf(lpToken.address);\n    const tokenAmount = getDisplayBalance(tokenAmountBN, 18);\n\n    const ftmAmountBN = await this.FTM.balanceOf(lpToken.address);\n    const ftmAmount = getDisplayBalance(ftmAmountBN, 18);\n    const tokenAmountInOneLP = Number(tokenAmount) / Number(lpTokenSupply);\n    const ftmAmountInOneLP = Number(ftmAmount) / Number(lpTokenSupply);\n    const lpTokenPrice = await this.getLPTokenPrice(lpToken, token0, isTomb);\n    const lpTokenPriceFixed = Number(lpTokenPrice).toFixed(2).toString();\n    const liquidity = (Number(lpTokenSupply) * Number(lpTokenPrice)).toFixed(2).toString();\n    return {\n      tokenAmount: tokenAmountInOneLP.toFixed(2).toString(),\n      ftmAmount: ftmAmountInOneLP.toFixed(2).toString(),\n      priceOfOne: lpTokenPriceFixed,\n      totalLiquidity: liquidity,\n      totalSupply: Number(lpTokenSupply).toFixed(2).toString(),\n    };\n  }\n\n  /**\n   * Use this method to get price for Apex\n   * @returns TokenStat for ABOND\n   * priceInFTM\n   * priceInDollars\n   * TotalSupply\n   * CirculatingSupply (always equal to total supply for bonds)\n   */\n  async getBondStat(): Promise<TokenStat> {\n    const { Treasury } = this.contracts;\n    const tombStat = await this.getTombStat();\n    const bondTombRatioBN = await Treasury.getBondPremiumRate();\n    const modifier = bondTombRatioBN / 1e18 > 1 ? bondTombRatioBN / 1e18 : 1;\n    const bondPriceInFTM = (Number(tombStat.tokenInFtm) * modifier).toFixed(2);\n    const priceOfTBondInDollars = (Number(tombStat.priceInDollars) * modifier).toFixed(2);\n    const supply = await this.ABOND.displayedTotalSupply();\n    return {\n      tokenInFtm: bondPriceInFTM,\n      priceInDollars: priceOfTBondInDollars,\n      totalSupply: supply,\n      circulatingSupply: supply,\n    };\n  }\n\n  /**\n   * @returns TokenStat for ASHARE\n   * priceInFTM\n   * priceInDollars\n   * TotalSupply\n   * CirculatingSupply (always equal to total supply for bonds)\n   */\n  async getShareStat(): Promise<TokenStat> {\n    const { ApexFtmLPAShareRewardPool } = this.contracts;\n\n    const supply = await this.ASHARE.totalSupply();\n\n    const priceInFTM = await this.getTokenPriceFromPancakeswap(this.ASHARE);\n    const tombRewardPoolSupply = await this.ASHARE.balanceOf(ApexFtmLPAShareRewardPool.address);\n    const tShareCirculatingSupply = supply.sub(tombRewardPoolSupply);\n    const priceOfOneFTM = await this.getWFTMPriceFromPancakeswap();\n    const priceOfSharesInDollars = (Number(priceInFTM) * Number(priceOfOneFTM)).toFixed(2);\n\n    return {\n      tokenInFtm: priceInFTM,\n      priceInDollars: priceOfSharesInDollars,\n      totalSupply: getDisplayBalance(supply, this.ASHARE.decimal, 0),\n      circulatingSupply: getDisplayBalance(tShareCirculatingSupply, this.ASHARE.decimal, 0),\n    };\n  }\n\n  async getTombStatInEstimatedTWAP(): Promise<TokenStat> {\n    const { SeigniorageOracle, ApexFtmRewardPool } = this.contracts;\n    const expectedPrice = await SeigniorageOracle.twap(this.APEX.address, ethers.utils.parseEther('1'));\n\n    const supply = await this.APEX.totalSupply();\n    const tombRewardPoolSupply = await this.APEX.balanceOf(ApexFtmRewardPool.address);\n    const tombCirculatingSupply = supply.sub(tombRewardPoolSupply);\n    return {\n      tokenInFtm: getDisplayBalance(expectedPrice),\n      priceInDollars: getDisplayBalance(expectedPrice),\n      totalSupply: getDisplayBalance(supply, this.APEX.decimal, 0),\n      circulatingSupply: getDisplayBalance(tombCirculatingSupply, this.APEX.decimal, 0),\n    };\n  }\n\n  async getTombPriceInLastTWAP(): Promise<BigNumber> {\n    const { Treasury } = this.contracts;\n    return Treasury.getApexUpdatedPrice();\n  }\n\n  async getBondsPurchasable(): Promise<BigNumber> {\n    const { Treasury } = this.contracts;\n    return Treasury.getBurnableApexLeft();\n  }\n\n  /**\n   * Calculates the TVL, APR and daily APR of a provided pool/bank\n   * @param bank\n   * @returns\n   */\n  async getPoolAPRs(bank: Bank): Promise<PoolStats> {\n    if (this.myAccount === undefined) return;\n    const depositToken = bank.depositToken;\n    const poolContract = this.contracts[bank.contract];\n    const depositTokenPrice = await this.getDepositTokenPriceInDollars(bank.depositTokenName, depositToken);\n    const stakeInPool = await depositToken.balanceOf(bank.address);\n    const TVL = Number(depositTokenPrice) * Number(getDisplayBalance(stakeInPool, depositToken.decimal));\n    const stat = bank.earnTokenName === 'APEX' ? await this.getTombStat() : await this.getShareStat();\n    const tokenPerSecond = await this.getTokenPerSecond(\n      bank.earnTokenName,\n      bank.contract,\n      poolContract,\n      bank.depositTokenName,\n    );\n\n    const tokenPerHour = tokenPerSecond.mul(60).mul(60);\n    const totalRewardPricePerYear =\n      Number(stat.priceInDollars) * Number(getDisplayBalance(tokenPerHour.mul(24).mul(365)));\n    const totalRewardPricePerDay = Number(stat.priceInDollars) * Number(getDisplayBalance(tokenPerHour.mul(24)));\n    const totalStakingTokenInPool =\n      Number(depositTokenPrice) * Number(getDisplayBalance(stakeInPool, depositToken.decimal));\n    const dailyAPR = (totalRewardPricePerDay / totalStakingTokenInPool) * 100;\n    const yearlyAPR = (totalRewardPricePerYear / totalStakingTokenInPool) * 100;\n    return {\n      dailyAPR: dailyAPR.toFixed(2).toString(),\n      yearlyAPR: yearlyAPR.toFixed(2).toString(),\n      TVL: TVL.toFixed(2).toString(),\n    };\n  }\n\n  /**\n   * Method to return the amount of tokens the pool yields per second\n   * @param earnTokenName the name of the token that the pool is earning\n   * @param contractName the contract of the pool/bank\n   * @param poolContract the actual contract of the pool\n   * @returns\n   */\n  async getTokenPerSecond(\n    earnTokenName: string,\n    contractName: string,\n    poolContract: Contract,\n    depositTokenName: string,\n  ) {\n    if (earnTokenName === 'APEX') {\n      if (!contractName.endsWith('ApexRewardPool')) {\n        const rewardPerSecond = await poolContract.apexPerSecond();\n        if (depositTokenName === 'WFTM') {\n          return rewardPerSecond.mul(6000).div(11000).div(24);\n        } else if (depositTokenName === 'BOO') {\n          return rewardPerSecond.mul(2500).div(11000).div(24);\n        } else if (depositTokenName === 'ZOO') {\n          return rewardPerSecond.mul(1000).div(11000).div(24);\n        } else if (depositTokenName === 'SHIBA') {\n          return rewardPerSecond.mul(1500).div(11000).div(24);\n        }\n        return rewardPerSecond.div(24);\n      }\n      const poolStartTime = await poolContract.poolStartTime();\n      const startDateTime = new Date(poolStartTime.toNumber() * 1000);\n      const FOUR_DAYS = 4 * 24 * 60 * 60 * 1000;\n      if (Date.now() - startDateTime.getTime() > FOUR_DAYS) {\n        return await poolContract.epochApexPerSecond(1);\n      }\n      return await poolContract.epochApexPerSecond(0);\n    }\n    const rewardPerSecond = await poolContract.AsharePerSecond();\n    if (depositTokenName === 'APEX-FTM-LP') {\n      return rewardPerSecond.mul(750).div(1000);\n    } else if (depositTokenName === 'ASHARE-FTM-LP'){\n      return rewardPerSecond.mul(90).div(1000);\n    } else if (depositTokenName === 'APEX'){\n      return rewardPerSecond.mul(160).div(1000);\n    }\n  }\n\n  /**\n   * Method to calculate the tokenPrice of the deposited asset in a pool/bank\n   * If the deposited token is an LP it will find the price of its pieces\n   * @param tokenName\n   * @param pool\n   * @param token\n   * @returns\n   */\n  async getDepositTokenPriceInDollars(tokenName: string, token: ERC20) {\n    let tokenPrice;\n    const priceOfOneFtmInDollars = await this.getWFTMPriceFromPancakeswap();\n    if (tokenName === 'WFTM') {\n      tokenPrice = priceOfOneFtmInDollars;\n    } else {\n      if (tokenName === 'APEX-FTM-LP') {\n        tokenPrice = await this.getLPTokenPrice(token, this.APEX, true);\n      } else if (tokenName === 'ASHARE-FTM-LP') {\n        tokenPrice = await this.getLPTokenPrice(token, this.ASHARE, false);\n      } else if (tokenName === 'SHIBA') {\n        tokenPrice = await this.getTokenPriceFromSpiritswap(token);\n      } else {\n        tokenPrice = await this.getTokenPriceFromPancakeswap(token);\n        tokenPrice = (Number(tokenPrice) * Number(priceOfOneFtmInDollars)).toString();\n      }\n    }\n    return tokenPrice;\n  }\n\n  //===================================================================\n  //===================== GET ASSET STATS =============================\n  //=========================== END ===================================\n  //===================================================================\n\n  async getCurrentEpoch(): Promise<BigNumber> {\n    const { Treasury } = this.contracts;\n    return Treasury.epoch();\n  }\n\n  async getBondOraclePriceInLastTWAP(): Promise<BigNumber> {\n    const { Treasury } = this.contracts;\n    return Treasury.getBondPremiumRate();\n  }\n\n  /**\n   * Buy bonds with cash.\n   * @param amount amount of cash to purchase bonds with.\n   */\n  async buyBonds(amount: string | number): Promise<TransactionResponse> {\n    const { Treasury } = this.contracts;\n    const treasuryTombPrice = await Treasury.getApexPrice();\n    return await Treasury.buyBonds(decimalToBalance(amount), treasuryTombPrice);\n  }\n\n  /**\n   * Redeem bonds for cash.\n   * @param amount amount of bonds to redeem.\n   */\n  async redeemBonds(amount: string): Promise<TransactionResponse> {\n    const { Treasury } = this.contracts;\n    const priceForTomb = await Treasury.getApexPrice();\n    return await Treasury.redeemBonds(decimalToBalance(amount), priceForTomb);\n  }\n\n  async getTotalValueLocked(): Promise<Number> {\n    let totalValue = 0;\n    for (const bankInfo of Object.values(bankDefinitions)) {\n      const pool = this.contracts[bankInfo.contract];\n      const token = this.externalTokens[bankInfo.depositTokenName];\n      const tokenPrice = await this.getDepositTokenPriceInDollars(bankInfo.depositTokenName, token);\n      const tokenAmountInPool = await token.balanceOf(pool.address);\n      const value = Number(getDisplayBalance(tokenAmountInPool, token.decimal)) * Number(tokenPrice);\n      const poolValue = Number.isNaN(value) ? 0 : value;\n      totalValue += poolValue;\n    }\n\n    const TSHAREPrice = (await this.getShareStat()).priceInDollars;\n    const masonrytShareBalanceOf = await this.ASHARE.balanceOf(this.currentMasonry().address);\n    const masonryTVL = Number(getDisplayBalance(masonrytShareBalanceOf, this.ASHARE.decimal)) * Number(TSHAREPrice);\n\n    return totalValue + masonryTVL;\n  }\n\n  /**\n   * Calculates the price of an LP token\n   * Reference https://github.com/DefiDebauchery/discordpricebot/blob/4da3cdb57016df108ad2d0bb0c91cd8dd5f9d834/pricebot/pricebot.py#L150\n   * @param lpToken the token under calculation\n   * @param token the token pair used as reference (the other one would be FTM in most cases)\n   * @param isTomb sanity check for usage of tomb token or tShare\n   * @returns price of the LP token\n   */\n  async getLPTokenPrice(lpToken: ERC20, token: ERC20, isTomb: boolean): Promise<string> {\n    const totalSupply = getFullDisplayBalance(await lpToken.totalSupply(), lpToken.decimal);\n    //Get amount of tokenA\n    const tokenSupply = getFullDisplayBalance(await token.balanceOf(lpToken.address), token.decimal);\n    const stat = isTomb === true ? await this.getTombStat() : await this.getShareStat();\n    const priceOfToken = stat.priceInDollars;\n    const tokenInLP = Number(tokenSupply) / Number(totalSupply);\n    const tokenPrice = (Number(priceOfToken) * tokenInLP * 2) //We multiply by 2 since half the price of the lp token is the price of each piece of the pair. So twice gives the total\n      .toString();\n    return tokenPrice;\n  }\n\n  async earnedFromBank(\n    poolName: ContractName,\n    earnTokenName: String,\n    poolId: Number,\n    account = this.myAccount,\n  ): Promise<BigNumber> {\n    const pool = this.contracts[poolName];\n    try {\n      if (earnTokenName === 'APEX') {\n        return await pool.pendingAPEX(poolId, account);\n      } else {\n        return await pool.pendingShare(poolId, account);\n      }\n    } catch (err) {\n      console.error(`Failed to call earned() on pool ${pool.address}: ${err.stack}`);\n      return BigNumber.from(0);\n    }\n  }\n\n  async stakedBalanceOnBank(poolName: ContractName, poolId: Number, account = this.myAccount): Promise<BigNumber> {\n    const pool = this.contracts[poolName];\n    try {\n      let userInfo = await pool.userInfo(poolId, account);\n      return await userInfo.amount;\n    } catch (err) {\n      console.error(`Failed to call balanceOf() on pool ${pool.address}: ${err.stack}`);\n      return BigNumber.from(0);\n    }\n  }\n\n  /**\n   * Deposits token to given pool.\n   * @param poolName A name of pool contract.\n   * @param amount Number of tokens with decimals applied. (e.g. 1.45 DAI * 10^18)\n   * @returns {string} Transaction hash\n   */\n  async stake(poolName: ContractName, poolId: Number, amount: BigNumber): Promise<TransactionResponse> {\n    const pool = this.contracts[poolName];\n    return await pool.deposit(poolId, amount);\n  }\n\n  /**\n   * Withdraws token from given pool.\n   * @param poolName A name of pool contract.\n   * @param amount Number of tokens with decimals applied. (e.g. 1.45 DAI * 10^18)\n   * @returns {string} Transaction hash\n   */\n  async unstake(poolName: ContractName, poolId: Number, amount: BigNumber): Promise<TransactionResponse> {\n    const pool = this.contracts[poolName];\n    return await pool.withdraw(poolId, amount);\n  }\n\n  /**\n   * Transfers earned token reward from given pool to my account.\n   */\n  async harvest(poolName: ContractName, poolId: Number): Promise<TransactionResponse> {\n    const pool = this.contracts[poolName];\n    //By passing 0 as the amount, we are asking the contract to only redeem the reward and not the currently staked token\n    return await pool.withdraw(poolId, 0);\n  }\n\n  /**\n   * Harvests and withdraws deposited tokens from the pool.\n   */\n  async exit(poolName: ContractName, poolId: Number, account = this.myAccount): Promise<TransactionResponse> {\n    const pool = this.contracts[poolName];\n    let userInfo = await pool.userInfo(poolId, account);\n    return await pool.withdraw(poolId, userInfo.amount);\n  }\n\n  async fetchMasonryVersionOfUser(): Promise<string> {\n    return 'latest';\n  }\n\n  currentMasonry(): Contract {\n    if (!this.masonryVersionOfUser) {\n      //throw new Error('you must unlock the wallet to continue.');\n    }\n    return this.contracts.Masonry;\n  }\n\n  isOldMasonryMember(): boolean {\n    return this.masonryVersionOfUser !== 'latest';\n  }\n\n  async getTokenPriceFromPancakeswap(tokenContract: ERC20): Promise<string> {\n    const ready = await this.provider.ready;\n    if (!ready) return;\n    const { chainId } = this.config;\n    const { WFTM } = this.config.externalTokens;\n\n    const wftm = new Token(chainId, WFTM[0], WFTM[1]);\n    const token = new Token(chainId, tokenContract.address, tokenContract.decimal, tokenContract.symbol);\n    try {\n      const wftmToToken = await Fetcher.fetchPairData(wftm, token, this.provider);\n      const priceInBUSD = new Route([wftmToToken], token);\n\n      return priceInBUSD.midPrice.toFixed(4);\n    } catch (err) {\n      console.error(`Failed to fetch token price of ${tokenContract.symbol}: ${err}`);\n    }\n  }\n\n  async getTokenPriceFromSpiritswap(tokenContract: ERC20): Promise<string> {\n    const ready = await this.provider.ready;\n    if (!ready) return;\n    const { chainId } = this.config;\n\n    const { WFTM } = this.externalTokens;\n\n    const wftm = new TokenSpirit(chainId, WFTM.address, WFTM.decimal);\n    const token = new TokenSpirit(chainId, tokenContract.address, tokenContract.decimal, tokenContract.symbol);\n    try {\n      const wftmToToken = await FetcherSpirit.fetchPairData(wftm, token, this.provider);\n      const liquidityToken = wftmToToken.liquidityToken;\n      let ftmBalanceInLP = await WFTM.balanceOf(liquidityToken.address);\n      let ftmAmount = Number(getFullDisplayBalance(ftmBalanceInLP, WFTM.decimal));\n      let shibaBalanceInLP = await tokenContract.balanceOf(liquidityToken.address);\n      let shibaAmount = Number(getFullDisplayBalance(shibaBalanceInLP, tokenContract.decimal));\n      const priceOfOneFtmInDollars = await this.getWFTMPriceFromPancakeswap();\n      let priceOfShiba = (ftmAmount / shibaAmount) * Number(priceOfOneFtmInDollars);\n      return priceOfShiba.toString();\n    } catch (err) {\n      console.error(`Failed to fetch token price of ${tokenContract.symbol}: ${err}`);\n    }\n  }\n\n  async getWFTMPriceFromPancakeswap(): Promise<string> {\n    const ready = await this.provider.ready;\n    if (!ready) return;\n    const { WFTM, FUSDT } = this.externalTokens;\n    try {\n      const fusdt_wftm_lp_pair = this.externalTokens['USDT-FTM-LP'];\n      let ftm_amount_BN = await WFTM.balanceOf(fusdt_wftm_lp_pair.address);\n      let ftm_amount = Number(getFullDisplayBalance(ftm_amount_BN, WFTM.decimal));\n      let fusdt_amount_BN = await FUSDT.balanceOf(fusdt_wftm_lp_pair.address);\n      let fusdt_amount = Number(getFullDisplayBalance(fusdt_amount_BN, FUSDT.decimal));\n      return (fusdt_amount / ftm_amount).toString();\n    } catch (err) {\n      console.error(`Failed to fetch token price of WFTM: ${err}`);\n    }\n  }\n\n  //===================================================================\n  //===================================================================\n  //===================== MASONRY METHODS =============================\n  //===================================================================\n  //===================================================================\n\n  async getMasonryAPR() {\n    const Masonry = this.currentMasonry();\n    const latestSnapshotIndex = await Masonry.latestSnapshotIndex();\n    const lastHistory = await Masonry.boardroomHistory(latestSnapshotIndex);\n\n    const lastRewardsReceived = lastHistory[1];\n\n    const TSHAREPrice = (await this.getShareStat()).priceInDollars;\n    const TOMBPrice = (await this.getTombStat()).priceInDollars;\n    const epochRewardsPerShare = lastRewardsReceived / 1e18;\n\n    //Mgod formula\n    const amountOfRewardsPerDay = epochRewardsPerShare * Number(TOMBPrice) * 4;\n    const masonrytShareBalanceOf = await this.ASHARE.balanceOf(Masonry.address);\n    const masonryTVL = Number(getDisplayBalance(masonrytShareBalanceOf, this.ASHARE.decimal)) * Number(TSHAREPrice);\n    const realAPR = ((amountOfRewardsPerDay * 100) / masonryTVL) * 365;\n    return realAPR;\n  }\n\n  /**\n   * Checks if the user is allowed to retrieve their reward from the Masonry\n   * @returns true if user can withdraw reward, false if they can't\n   */\n  async canUserClaimRewardFromMasonry(): Promise<boolean> {\n    const Masonry = this.currentMasonry();\n    return await Masonry.canClaimReward(this.myAccount);\n  }\n\n  /**\n   * Checks if the user is allowed to retrieve their reward from the Masonry\n   * @returns true if user can withdraw reward, false if they can't\n   */\n  async canUserUnstakeFromMasonry(): Promise<boolean> {\n    const Masonry = this.currentMasonry();\n    const canWithdraw = await Masonry.canWithdraw(this.myAccount);\n    const stakedAmount = await this.getStakedSharesOnMasonry();\n    const notStaked = Number(getDisplayBalance(stakedAmount, this.ASHARE.decimal)) === 0;\n    const result = notStaked ? true : canWithdraw;\n    return result;\n  }\n\n  async timeUntilClaimRewardFromMasonry(): Promise<BigNumber> {\n    // const Masonry = this.currentMasonry();\n    // const mason = await Masonry.masons(this.myAccount);\n    return BigNumber.from(0);\n  }\n\n  async getTotalStakedInMasonry(): Promise<BigNumber> {\n    const Masonry = this.currentMasonry();\n    return await Masonry.totalSupply();\n  }\n\n  async stakeShareToMasonry(amount: string): Promise<TransactionResponse> {\n    if (this.isOldMasonryMember()) {\n      throw new Error(\"you're using old masonry. please withdraw and deposit the ASHARE again.\");\n    }\n    const Masonry = this.currentMasonry();\n    return await Masonry.stake(decimalToBalance(amount));\n  }\n\n  async getStakedSharesOnMasonry(): Promise<BigNumber> {\n    const Masonry = this.currentMasonry();\n    if (this.masonryVersionOfUser === 'v1') {\n      return await Masonry.getShareOf(this.myAccount);\n    }\n    return await Masonry.balanceOf(this.myAccount);\n  }\n\n  async getEarningsOnMasonry(): Promise<BigNumber> {\n    const Masonry = this.currentMasonry();\n    if (this.masonryVersionOfUser === 'v1') {\n      return await Masonry.getCashEarningsOf(this.myAccount);\n    }\n    return await Masonry.earned(this.myAccount);\n  }\n\n  async withdrawShareFromMasonry(amount: string): Promise<TransactionResponse> {\n    const Masonry = this.currentMasonry();\n    return await Masonry.withdraw(decimalToBalance(amount));\n  }\n\n  async harvestCashFromMasonry(): Promise<TransactionResponse> {\n    const Masonry = this.currentMasonry();\n    if (this.masonryVersionOfUser === 'v1') {\n      return await Masonry.claimDividends();\n    }\n    return await Masonry.claimReward();\n  }\n\n  async exitFromMasonry(): Promise<TransactionResponse> {\n    const Masonry = this.currentMasonry();\n    return await Masonry.exit();\n  }\n\n  async allocateSeigniorage(): Promise<TransactionResponse> {\n    const { Treasury } = this.contracts;\n    return await Treasury.allocateSeigniorage();\n  }\n\n  async getTreasuryNextAllocationTime(): Promise<AllocationTime> {\n    const { Treasury } = this.contracts;\n    const nextEpochTimestamp: BigNumber = await Treasury.nextEpochPoint();\n    const nextAllocation = new Date(nextEpochTimestamp.mul(1000).toNumber());\n    const prevAllocation = new Date(Date.now());\n\n    return { from: prevAllocation, to: nextAllocation };\n  }\n  /**\n   * This method calculates and returns in a from to to format\n   * the period the user needs to wait before being allowed to claim\n   * their reward from the masonry\n   * @returns Promise<AllocationTime>\n   */\n  async getUserClaimRewardTime(): Promise<AllocationTime> {\n    const { Masonry, Treasury } = this.contracts;\n    const nextEpochTimestamp = await Masonry.nextEpochPoint(); //in unix timestamp\n    const currentEpoch = await Masonry.epoch();\n    const mason = await Masonry.boards(this.myAccount);\n    const startTimeEpoch = mason.epochTimerStart;\n    const period = await Treasury.PERIOD();\n    const periodInHours = period / 60 / 60; // 6 hours, period is displayed in seconds which is 21600\n    const rewardLockupEpochs = await Masonry.rewardLockupEpochs();\n    const targetEpochForClaimUnlock = Number(startTimeEpoch) + Number(rewardLockupEpochs);\n\n    const fromDate = new Date(Date.now());\n    if (targetEpochForClaimUnlock - currentEpoch <= 0) {\n      return { from: fromDate, to: fromDate };\n    } else if (targetEpochForClaimUnlock - currentEpoch === 1) {\n      const toDate = new Date(nextEpochTimestamp * 1000);\n      return { from: fromDate, to: toDate };\n    } else {\n      const toDate = new Date(nextEpochTimestamp * 1000);\n      const delta = targetEpochForClaimUnlock - currentEpoch - 1;\n      const endDate = moment(toDate)\n        .add(delta * periodInHours, 'hours')\n        .toDate();\n      return { from: fromDate, to: endDate };\n    }\n  }\n\n  /**\n   * This method calculates and returns in a from to to format\n   * the period the user needs to wait before being allowed to unstake\n   * from the masonry\n   * @returns Promise<AllocationTime>\n   */\n  async getUserUnstakeTime(): Promise<AllocationTime> {\n    const { Masonry, Treasury } = this.contracts;\n    const nextEpochTimestamp = await Masonry.nextEpochPoint();\n    const currentEpoch = await Masonry.epoch();\n    const mason = await Masonry.boards(this.myAccount);\n    const startTimeEpoch = mason.epochTimerStart;\n    const period = await Treasury.PERIOD();\n    const PeriodInHours = period / 60 / 60;\n    const withdrawLockupEpochs = await Masonry.withdrawLockupEpochs();\n    const fromDate = new Date(Date.now());\n    const targetEpochForClaimUnlock = Number(startTimeEpoch) + Number(withdrawLockupEpochs);\n    const stakedAmount = await this.getStakedSharesOnMasonry();\n    if (currentEpoch <= targetEpochForClaimUnlock && Number(stakedAmount) === 0) {\n      return { from: fromDate, to: fromDate };\n    } else if (targetEpochForClaimUnlock - currentEpoch === 1) {\n      const toDate = new Date(nextEpochTimestamp * 1000);\n      return { from: fromDate, to: toDate };\n    } else {\n      const toDate = new Date(nextEpochTimestamp * 1000);\n      const delta = targetEpochForClaimUnlock - Number(currentEpoch) - 1;\n      const endDate = moment(toDate)\n        .add(delta * PeriodInHours, 'hours')\n        .toDate();\n      return { from: fromDate, to: endDate };\n    }\n  }\n\n  async watchAssetInMetamask(assetName: string): Promise<boolean> {\n    const { ethereum } = window as any;\n    if (ethereum && ethereum.networkVersion === config.chainId.toString()) {\n      let asset;\n      let assetUrl;\n      if (assetName === 'APEX') {\n        asset = this.APEX;\n        assetUrl = 'https://tomb.finance/presskit/tomb_icon_noBG.png';\n      } else if (assetName === 'ASHARE') {\n        asset = this.ASHARE;\n        assetUrl = 'https://tomb.finance/presskit/tshare_icon_noBG.png';\n      } else if (assetName === 'ABOND') {\n        asset = this.ABOND;\n        assetUrl = 'https://tomb.finance/presskit/tbond_icon_noBG.png';\n      }\n      await ethereum.request({\n        method: 'wallet_watchAsset',\n        params: {\n          type: 'ERC20',\n          options: {\n            address: asset.address,\n            symbol: asset.symbol,\n            decimals: 18,\n            image: assetUrl,\n          },\n        },\n      });\n    }\n    return true;\n  }\n\n  async provideTombFtmLP(ftmAmount: string, tombAmount: BigNumber): Promise<TransactionResponse> {\n    const { TaxOffice } = this.contracts;\n    let overrides = {\n      value: parseUnits(ftmAmount, 18),\n    };\n    return await TaxOffice.addLiquidityETHTaxFree(tombAmount, tombAmount.mul(992).div(1000), parseUnits(ftmAmount, 18).mul(992).div(1000), overrides);\n  }\n\n  async quoteFromSpooky(tokenAmount: string, tokenName: string): Promise<string> {\n    const { SpookyRouter } = this.contracts;\n    const { _reserve0, _reserve1 } = await this.TOMBWFTM_LP.getReserves();\n    let quote;\n    if (tokenName === 'APEX') {\n      quote = await SpookyRouter.quote(parseUnits(tokenAmount), _reserve1, _reserve0);\n    } else {\n      quote = await SpookyRouter.quote(parseUnits(tokenAmount), _reserve0, _reserve1);\n    }\n    return (quote / 1e18).toString();\n  }\n\n  /**\n   * @returns an array of the regulation events till the most up to date epoch\n   */\n  async listenForRegulationsEvents(): Promise<any> {\n    const { Treasury } = this.contracts;\n\n    const treasuryDaoFundedFilter = Treasury.filters.DaoFundFunded();\n    const treasuryDevFundedFilter = Treasury.filters.DevFundFunded();\n    const treasuryMasonryFundedFilter = Treasury.filters.MasonryFunded();\n    const boughtBondsFilter = Treasury.filters.BoughtBonds();\n    const redeemBondsFilter = Treasury.filters.RedeemedBonds();\n\n    let epochBlocksRanges: any[] = [];\n    let masonryFundEvents = await Treasury.queryFilter(treasuryMasonryFundedFilter);\n    var events: any[] = [];\n    masonryFundEvents.forEach(function callback(value, index) {\n      events.push({ epoch: index + 1 });\n      events[index].masonryFund = getDisplayBalance(value.args[1]);\n      if (index === 0) {\n        epochBlocksRanges.push({\n          index: index,\n          startBlock: value.blockNumber,\n          boughBonds: 0,\n          redeemedBonds: 0,\n        });\n      }\n      if (index > 0) {\n        epochBlocksRanges.push({\n          index: index,\n          startBlock: value.blockNumber,\n          boughBonds: 0,\n          redeemedBonds: 0,\n        });\n        epochBlocksRanges[index - 1].endBlock = value.blockNumber;\n      }\n    });\n\n    epochBlocksRanges.forEach(async (value, index) => {\n      events[index].bondsBought = await this.getBondsWithFilterForPeriod(\n        boughtBondsFilter,\n        value.startBlock,\n        value.endBlock,\n      );\n      events[index].bondsRedeemed = await this.getBondsWithFilterForPeriod(\n        redeemBondsFilter,\n        value.startBlock,\n        value.endBlock,\n      );\n    });\n    let DEVFundEvents = await Treasury.queryFilter(treasuryDevFundedFilter);\n    DEVFundEvents.forEach(function callback(value, index) {\n      events[index].devFund = getDisplayBalance(value.args[1]);\n    });\n    let DAOFundEvents = await Treasury.queryFilter(treasuryDaoFundedFilter);\n    DAOFundEvents.forEach(function callback(value, index) {\n      events[index].daoFund = getDisplayBalance(value.args[1]);\n    });\n    return events;\n  }\n\n  /**\n   * Helper method\n   * @param filter applied on the query to the treasury events\n   * @param from block number\n   * @param to block number\n   * @returns the amount of bonds events emitted based on the filter provided during a specific period\n   */\n  async getBondsWithFilterForPeriod(filter: EventFilter, from: number, to: number): Promise<number> {\n    const { Treasury } = this.contracts;\n    const bondsAmount = await Treasury.queryFilter(filter, from, to);\n    return bondsAmount.length;\n  }\n\n  async estimateZapIn(tokenName: string, lpName: string, amount: string): Promise<number[]> {\n    const { zapper } = this.contracts;\n    const lpToken = this.externalTokens[lpName];\n    let estimate;\n    if (tokenName === FTM_TICKER) {\n      estimate = await zapper.estimateZapIn(lpToken.address, SPOOKY_ROUTER_ADDR, parseUnits(amount, 18));\n    } else {\n      const token = tokenName === TOMB_TICKER ? this.APEX : this.ASHARE;\n      estimate = await zapper.estimateZapInToken(\n        token.address,\n        lpToken.address,\n        SPOOKY_ROUTER_ADDR,\n        parseUnits(amount, 18),\n      );\n    }\n    return [estimate[0] / 1e18, estimate[1] / 1e18];\n  }\n  async zapIn(tokenName: string, lpName: string, amount: string): Promise<TransactionResponse> {\n    const { zapper } = this.contracts;\n    const lpToken = this.externalTokens[lpName];\n    if (tokenName === FTM_TICKER) {\n      let overrides = {\n        value: parseUnits(amount, 18),\n      };\n      return await zapper.zapIn(lpToken.address, SPOOKY_ROUTER_ADDR, this.myAccount, overrides);\n    } else {\n      const token = tokenName === TOMB_TICKER ? this.APEX : this.ASHARE;\n      return await zapper.zapInToken(\n        token.address,\n        parseUnits(amount, 18),\n        lpToken.address,\n        SPOOKY_ROUTER_ADDR,\n        this.myAccount,\n      );\n    }\n  }\n  async swapTBondToTShare(tbondAmount: BigNumber): Promise<TransactionResponse> {\n    const { TShareSwapper } = this.contracts;\n    return await TShareSwapper.swapTBondToTShare(tbondAmount);\n  }\n  async estimateAmountOfTShare(tbondAmount: string): Promise<string> {\n    const { TShareSwapper } = this.contracts;\n    try {\n      const estimateBN = await TShareSwapper.estimateAmountOfTShare(parseUnits(tbondAmount, 18));\n      return getDisplayBalance(estimateBN, 18, 6);\n    } catch (err) {\n      console.error(`Failed to fetch estimate tshare amount: ${err}`);\n    }\n  }\n\n  async getTShareSwapperStat(address: string): Promise<TShareSwapperStat> {\n    const { TShareSwapper } = this.contracts;\n    const tshareBalanceBN = await TShareSwapper.getTShareBalance();\n    const tbondBalanceBN = await TShareSwapper.getTBondBalance(address);\n    // const tombPriceBN = await TShareSwapper.getTombPrice();\n    // const tsharePriceBN = await TShareSwapper.getTSharePrice();\n    const rateTSharePerTombBN = await TShareSwapper.getTShareAmountPerTomb();\n    const tshareBalance = getDisplayBalance(tshareBalanceBN, 18, 5);\n    const tbondBalance = getDisplayBalance(tbondBalanceBN, 18, 5);\n    return {\n      tshareBalance: tshareBalance.toString(),\n      tbondBalance: tbondBalance.toString(),\n      // tombPrice: tombPriceBN.toString(),\n      // tsharePrice: tsharePriceBN.toString(),\n      rateTSharePerTomb: rateTSharePerTombBN.toString(),\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}